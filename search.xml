<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>动态规划</title>
    <url>/2024/03/19/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h3 id="DP分析操作举例："><a href="#DP分析操作举例：" class="headerlink" title="DP分析操作举例："></a>DP分析操作举例：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">									 ---所有选法</span><br><span class="line">									|</span><br><span class="line">						 ------------集合（即满足条件中的所有选法）</span><br><span class="line">						 |			|</span><br><span class="line">	----状态表示<span class="built_in">f</span>(i,j)-----	 		  ---条件：①只从前个物品中选，②总体积&lt;=j</span><br><span class="line">	|(即满足属性的集合中的值)|</span><br><span class="line">	|					 ---属性：每一个<span class="built_in">f</span>(i,j)代表:Max,Min,Sum...</span><br><span class="line">Dp--</span><br><span class="line">    |</span><br><span class="line">	|</span><br><span class="line">    ----状态计算（集合划分）：eg：<span class="number">01</span>背包的问题：划分两部分，包含i（物品），不包含i。<span class="built_in">f</span>(i,j) = <span class="built_in">max</span>(<span class="built_in">f</span>(i<span class="number">-1</span>,j)，<span class="built_in">f</span>(i<span class="number">-1</span>,j-vi) + wi)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>初始化：考虑边界时，题目要求。</p>
</li>
<li><p>通过集合划分，写出朴素状态方程</p>
</li>
<li><p>需要几维的dp，从一维开始往上思考。</p>
</li>
<li><p>dp中的下标表示什么很重要。</p>
</li>
<li><p>动态规划时间复杂度计算：状态数量*计算每个状态的个数。</p>
</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><ul>
<li><p>数组优化为滚动数组时，考虑从前到后还是从后到前，主要看，它的状态转移，是用到上一层的数组（后往前，免覆盖），还是本层数组（前往后，需用到前）。</p>
</li>
<li><p>01背包：每件物品最多只用一次</p>
<ul>
<li><p>朴素写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="comment">//不可合并为(j&gt;=v[i])dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]]+w[i])</span></span><br><span class="line">            <span class="comment">//若合并，这就会将两种情况合并在一起，失去了不选择第i个物品的情况</span></span><br><span class="line">            <span class="comment">//原本两种情况是：不选择第i个物品，当前的最优值就等于前一个状态；选择第i个物品，</span></span><br><span class="line">            <span class="comment">//那么当前的最优值应该考虑前一个状态（dp[i-1][j-v[i]]）加上当前物品的价值w[i]。</span></span><br><span class="line">            <span class="comment">//因为不选择第i个物品的情况，也被纳入了j&gt;=v[i]时才可使用，而j&gt;=v[i]本来就是选v[i].</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i])dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i<span class="number">-1</span>][j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>滚动数组优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)<span class="comment">//从后往前，因为原方程为从i-1层取东西，所以j又是往前面东西，前面存的是上一层的，若正序，则前面先被覆盖，则导致后面取得不是上一层的。</span></span><br><span class="line">       &#123;</span><br><span class="line">           dp[j] = <span class="built_in">max</span>(dp[j], dp[j-v[i]]+w[i]);<span class="comment">//dp[j]用的前面的没有选i的部分，所以不需要有：dp[i][j] = dp[i-1][j];。这一个从上往下数组，不这样，就会没选到：不选的。而滚动，则上一层的结果保留在本层。</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>完全背包：每件物品有无限个</p>
<ul>
<li><p>细节问题：关于不选物品时，第三重循环和第二重循环要不要写诸如：<code>f[i][j] = f[i-1][j]</code>。</p>
</li>
<li><p>集合划分成若干组，即：按照第i个物品选择个数（0~k部分，即该物品选0，1，2…..k个，最多选k（包满））</p>
<ul>
<li><p>朴素做法：三重循环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) <span class="comment">//容量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;  k*v[i] &lt;= j; k++) <span class="comment">//物品个数</span></span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-k*v[i]]+w[i]);<span class="comment">//与f[i][j]比较是因为，k一直变大，f[i][j]是原来的k。</span></span><br><span class="line"><span class="comment">//此处不需要 f[i][j] = f[i-1][j];，因为k=0就表示不选。要写的话，应该写在 二重循环j 与 三重循环k 之间。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>优化做法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) <span class="comment">//容量</span></span><br><span class="line">    &#123;</span><br><span class="line">        f[i][j] = f[i<span class="number">-1</span>][j];<span class="comment">//不选，此处需要这个，表示不选</span></span><br><span class="line">        <span class="keyword">if</span>(j &gt;= v[i])f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j-v[i]]+w[i]); <span class="comment">//从i开始，不选，和选k个。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>滚动数组优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = v[i]; j &lt;= m; j++) <span class="comment">//容量,这里不用倒序，因为原本都是从i层的前面算过来的。见优化前的方程f[i][j] = max(f[i][j],f[i][j-v[i]]),都是i,而且还是从前面来的，因为j-v[i]&lt;j</span></span><br><span class="line">    &#123;</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]]+w[i]); <span class="comment">//不需要dp[i][j] = dp[i-1][j];这样子的，因为滚动，则上一层的内容就被保留在了本层。其最前面的内容就包含了不选。又完全背包，优化公式得，不选和选一个，选一个和选两个,,,,逐一增加，每次将前面得覆盖也不会影响。因为正好需要前面的。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>多重背包：每个物品有$S_i$个</p>
<ul>
<li><p>朴素版本的多重背包，和完全背包类似，集合划分<code>s[i]</code>块，状态方程得到：<code>f[i][j] = max(f[i][j-k*v[i]]+k*w[i])</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i<span class="number">-1</span>][j-k*v[i]] + k*w[i]);<span class="comment">//不写f[i][j] = f[i-1][j],这表示不选，当k=0时就不选。若非要写，写在循环j与k之间。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>优化：不能用完全背包的优化方法，因为不太一样（最后多了一项），如果求MAX等操作。但是若是求SUM的话，倒是可以通过f的加减法变化一下得到。</p>
<ul>
<li><p><strong>二进制优化：</strong>即对于每一个物品有$S_i$个，$S_i$都可以由小于$S_i$的二进制的和得到。（但是：所有二进制相加&lt;$S_i$,所以，</p>
<ul>
<li><p>eg：200则最大64，可凑到127，则再补上一个73，则可以表示0<del>200的所有数量。$200 &#x3D; 1+2+4…+2^k+c, c&lt;2^{k+1}$,<br>$$<br>即：1,2,4,8,16.他们的二进制分别为：\<br>  00001,00010,00100,01000,10000,\<br>  则他们根据C_n^m可以选出很多种\<br>  (每一个都是01背包问题，即选与不选)组合，\<br>  包括了从00000</del>11111的所有值。<br>$$</p>
</li>
<li><p>所以，最后就是将第i个物品$S_i$   -（拆分）-&gt;$log_{S_i}$组新的物品，每个新的物品只能选一次，对所有新的物品 共做一次<strong>01背包</strong>（选，不选），即可。</p>
<ul>
<li><p>复杂度：$O(N<em>V</em>log{S_i})$，开数组时，根据$S_i$和$N$求和计算共需多少空间。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二进制预处理</span></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, s;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &lt;= s) <span class="comment">//s个数，k为二进制值1，2，4，...</span></span><br><span class="line">    &#123;</span><br><span class="line">        cnt ++; <span class="comment">//从1开始用。因为0，即不选任何物品。</span></span><br><span class="line">        v[cnt] = a * k;<span class="comment">//体积。cnt表示存储位置，将所有物品拆分成k组，每组作为一个新的物品。将所有组的拆分后都放入，获得一个全新01背包。</span></span><br><span class="line">        w[cnt] = b * k;</span><br><span class="line">        s -= k;</span><br><span class="line">        k *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s &gt; <span class="number">0</span>)<span class="comment">//第i件物品仍有剩余</span></span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        v[cnt] = a * s;</span><br><span class="line">        w[cnt] = b * s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">n = cnt;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j--)<span class="comment">//也是倒序，因为变成01背包</span></span><br><span class="line">f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]] + w[i]);</span><br><span class="line"><span class="comment">//原朴素写法：f[i][j] = f[i-1][j];//不选、</span></span><br><span class="line"><span class="comment">//if(j&gt;=v[i]) f[i][j] = max(f[i][j], f[i-1][j-v[i]]+w[i])，即不选与选之间谁大。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​    </p>
<ul>
<li><p>分组背包：有N组物品，每组物品最多选一样（即每组，选哪个）。</p>
<ul>
<li><p>与多重背包思路一样。也是k循环。只是没有<code>k*v[i]&lt;=j</code>,而是<code>v[i][k]&lt;=j</code></p>
</li>
<li><p>滚动数组优化时，也是j倒序，因为每组的每一个物品都不同，可以认为是每组中，该组物品的01背包。（因为用到了前面的不同物品（包括不选时，之前的物品））</p>
</li>
<li><p>朴素算法:</p>
<ul>
<li><p>注意事项：if不可放到外面</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//物品，0为没选任何物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i];k++)<span class="comment">//没有k*v[i][k]...，因为不会有多选同一物品。</span></span><br><span class="line">            <span class="comment">//if不可放到k循环里，因为会导致提前退出，从而后面的不大于容量的物品没有被dp到。</span></span><br><span class="line">            <span class="comment">//if这里面已经包含不选:f[i][j]=f[i-1][j]。因为当k=0时，v为0，则必有&lt;=j.</span></span><br><span class="line">            <span class="keyword">if</span>(v[i][k]&lt;=j)</span><br><span class="line">				f[i][j] = <span class="built_in">max</span>(f[i][j], f[i][j-v[i][k]]+w[i][k]);<span class="comment">//不用写f[i][j] = f[i-1][j],因为k=0就是全部都不选</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>滚动优化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)<span class="comment">//倒序，因为每一个都需要用到前面的选择进行比较。滚动需要前面的选择的类型。（不是同一个物品的，若同一个就不必这么麻烦了。）</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i]; k++)</span><br><span class="line">            <span class="keyword">if</span>(v[i][k]&lt;=j)<span class="comment">//if不可放到k循环里，因为会导致提前退出，从而后面的不大于容量的物品没有被dp到。</span></span><br><span class="line">				f[j] = <span class="built_in">max</span>(f[j], f[j-v[i][k]]+w[i][k]);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>混合背包：以上组合。</p>
</li>
</ul>
<hr>
<h3 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h3><ul>
<li><p>递推方程具有明显线性</p>
</li>
<li><p>例题1：</p>
<ul>
<li><p>数字三角形</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化时要先将其周围都初始化了</span></span><br><span class="line"><span class="comment">//f[i][j] = max(f[i-1][j-1]+a[i], f[i-1][j]+a[i]);</span></span><br><span class="line"><span class="comment">//res = max(f[i][j]);//最后一层很多路径，找最大的</span></span><br><span class="line"><span class="comment">//或者自底向上做也可以。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>例题2：</p>
<ul>
<li><p>最长上升子序列一</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不必连续</span></span><br><span class="line"><span class="comment">//dp[i],i表示以[i]结尾的最大子序列长度</span></span><br><span class="line"><span class="comment">//dp[i]则为其前面一个符合要求的所有数的最长子序列+1.</span></span><br><span class="line"><span class="comment">//0表示上一个数是0下标，i-1表示上一个数是i-1下标，在这些所有符合要求的中求max</span></span><br><span class="line"><span class="comment">//O(n^2)时间复杂度。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>最长上升子序列二</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure>


</li>
<li><p>最长公共子序列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般涉及两个序列的，是二维表示[i][j]，即第一个字符串的前i个字符，第二个字符串的前j个字符</span></span><br><span class="line"><span class="comment">//集合划分依据：a[i],b[j]选不选。共4种情况</span></span><br><span class="line"><span class="comment">//下图中01，10的表达式不是下面的，因为，这01，10表示选i，不选j（or...）的情况。但是f[i-1,j],f[i,j-1]里面包含这两种情况，所以可以代表。</span></span><br><span class="line"><span class="comment">//第一种情况00包含于01，10中。所以不用写。这种情况</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>例题3：</p>
<ul>
<li>最短编辑距离</li>
<li>编辑距离</li>
</ul>
</li>
</ul>
<hr>
<h3 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h3><ul>
<li><p>区间DP用递归可能更好（记忆化搜索）</p>
</li>
<li><p>石子合并</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//f[i][j],表示从第i个到第j个的区间，所有第i堆 到 第j堆石子合并为1堆的 花费最小值</span></span><br><span class="line"><span class="comment">//将石子划分成两堆，两堆里面求最小值，再把最后该两堆合并（sum[i~j])--》前缀和</span></span><br><span class="line"><span class="comment">//区间dp，确保再用到之前，该数据已经被求出来（可从小区间到大区间枚举范围，</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="计数DP"><a href="#计数DP" class="headerlink" title="计数DP"></a>计数DP</h3><h3 id="数位统计DP"><a href="#数位统计DP" class="headerlink" title="数位统计DP"></a>数位统计DP</h3><ul>
<li>对于取0，要避免取000，不能有前导0</li>
</ul>
<h3 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h3><h3 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h3><h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3>]]></content>
      <categories>
        <category>算法板子</category>
      </categories>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/2024/03/19/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h3><ul>
<li><p>快排板子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x = q[(l + r) &gt;&gt; <span class="number">1</span>]; <span class="comment">//x = q[l], x=q[r];但是x=q[l + r &gt;&gt; 1]效率最高</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//若i: i-1,i ,对应x = (l+r+1)&gt;&gt;1 或 r，保证上取整，否则死循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>
</li>
<li><p>归并板子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>二分板子</p>
<ul>
<li><p>整数二分</p>
<ul>
<li><p>左边界</p>
</li>
<li><p>右边界</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;<span class="comment">//一般为:a[mid]&lt;=x, mid已左下取整，所以不用mid-1，向下取整则r往左取边界（包含if(a[mid]==x)这一答案了</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="comment">//一般为:a[mid]&gt;=x, mid已右上（mid有+1）取整，所以不用mid+1，向上取整则l往往取边界（包含if(a[mid]==x)这一答案了</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可用于求区间范围等，第一种是默认l(除左）,第二种是默认r（除右）</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>实数二分（float二分）</p>
<ul>
<li><p>while至少比要求有效位数多两个精度（进位精度）</p>
</li>
<li><p>或for循环100次（精度基本绝对够了$2^{-100}$）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">//不可以&gt;&gt;1.0，因为移位针对整数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对某些例题，如开根，可能有数字在-1~1之间，这样如果，l=0,r=n的话，可能存在l和r的区间本来就不包含正确答案，不妨按照题目n范围，设置l和r，多迭代几次，这样，能确保所有答案都在里面。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>高精度板子</p>
<ul>
<li><p>倒序相加，倒序输出。(string a, b)</p>
</li>
<li><p>高精度加法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用vector方便，不用统计size</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i++) <span class="comment">//满足一个继续。下面的if判断是否加超过size的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">    	<span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">    	c.<span class="built_in">push_back</span>(t%<span class="number">10</span>); <span class="comment">//除掉进位</span></span><br><span class="line">    	t /= <span class="number">10</span>; <span class="comment">//进位</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(t) c.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//若t仍有进位（最高位）</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//string a, b; cin&gt;&gt;a&gt;&gt;b; //a=&#x27;12345&#x27; for(int i = a.size()-1; i&gt;=0; i--) A.push_back(a[i]-&#x27;0&#x27;); //相对偏移且倒序，确保低位相加</span></span><br><span class="line"><span class="comment">//for(int i = c.size()-1; i&gt;=0; i++) cout&lt;&lt;c[i];//倒序输出 </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>高精度减法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//减法需要判断正负</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>(); <span class="comment">//A&gt;B:true,else false</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(A[i]!=B[i]) <span class="keyword">return</span> A[i]&gt;B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//全相等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, vector&lt;<span class="type">int</span>&gt; B)</span><span class="comment">//在main处理了A大于B，也可以在这里处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t; <span class="comment">//先剪掉借位</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        c.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>);<span class="comment">//保证了t&gt;0,仍为t，t&lt;0,为补码</span></span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;<span class="comment">//有借位，为1，不是-1.t为借位标记。</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;<span class="comment">//无</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; c.<span class="built_in">back</span>() == <span class="number">0</span>) c.<span class="built_in">pop_back</span>(); <span class="comment">//去掉前导0</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = b.<span class="built_in">size</span>()<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) B.<span class="built_in">push_back</span>(b[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">auto</span> c = <span class="built_in">Sub</span>(A, B); </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = c.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            cout&lt;&lt;c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> c = <span class="built_in">Sub</span>(B, A);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = c.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            cout&lt;&lt;c[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高精度乘低精度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(A[i]+t)%10为本位, /10为进位</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">		t =  t + A[i] * b; <span class="comment">//加t，进位。</span></span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>; <span class="comment">//进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) c.<span class="built_in">push_back</span>(t);<span class="comment">//最高位进位</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高精度除低精度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A/b, r为余数，c为商</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span> &gt; c;</span><br><span class="line">    r = <span class="number">0</span>;<span class="comment">//余数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];<span class="comment">//no ：r&lt;&lt;1,此为2进制</span></span><br><span class="line">        c.<span class="built_in">push_back</span>(r/b); <span class="comment">//商数位，从高到低</span></span><br><span class="line">        r %= b;<span class="comment">//余数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());<span class="comment">//用于删除前导零，要反转：pop.back()</span></span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; c.<span class="built_in">back</span>()==<span class="number">0</span>) c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>前缀和</p>
<ul>
<li><p>一维</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], s[N]; <span class="comment">//a为元素，s为前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preSum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> <span class="comment">//a也是从[1]开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间求和：[r, l] : sum = s[r] - s[l-1]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>二维</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N][N], s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preSum</span><span class="params">(<span class="type">int</span> **a, <span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>] + a[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间求和[(x1,y1),(x2,y2)]：sum = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>差分</p>
<ul>
<li><p>一维</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造b为a的差分，则a为b的前缀和</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间每个数+c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//差分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">insert</span>(i, i, a[i]); <span class="comment">//先初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] += b[i<span class="number">-1</span>]; <span class="comment">//求前缀和。</span></span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= n; i++) cout&lt;&lt;b[i];</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>二维</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//差分区间改变+c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>] -= c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//差分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="built_in">insert</span>(i, j, i, j, a[i][j]);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(x1, y1, x2, y2, c); <span class="comment">//区间+c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;=m; j++)</span><br><span class="line">        b[i][j] += b[i<span class="number">-1</span>][j] + b[i][j<span class="number">-1</span>] - b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        cout&lt;&lt;b[i][j];<span class="comment">//输出。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>位运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题种1：求第k位为0/1：</span></span><br><span class="line">n &gt;&gt;= k <span class="comment">//(n为10进制的2表示，左移k位)</span></span><br><span class="line">cout&lt;&lt;n&amp;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//题种2：求1的个数（每次返回最后一个1的大小，原数减去其，继续操作，直到为0）</span></span><br><span class="line"><span class="comment">//lowbit取补码操作，常用于树状数组，在c++中，-x用补码表示，即-x = ~x+1</span></span><br><span class="line"><span class="comment">//返回n的最后一位1：</span></span><br><span class="line"><span class="built_in">lowbit</span>(n) = n &amp; -n;<span class="comment">//-n为补码</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>双指针</p>
</li>
<li><p>用不习惯。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//j为slow指针，i为fast指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; i &amp;&amp; <span class="built_in">check</span>(i,j)) j++; </span><br><span class="line">    <span class="comment">//问题逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我的逻辑：一般先将题目排序（若可），再指针迭代（同上，类似）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一般具有某种单调关系。</span></span><br><span class="line"><span class="comment">//常见问题分类：</span></span><br><span class="line"><span class="comment">//(1) 对于一个序列，用两个指针维护一段区间</span></span><br><span class="line"><span class="comment">//(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span></span><br></pre></td></tr></table></figure>




</li>
<li><p>离散化</p>
<ul>
<li>即将大数映射到小index上（即使得离散化数据连续存储）（保序离散化：小更小，大更大。即映射下标）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组a中可能有重复元素，需要去重：vector排序去重</span></span><br><span class="line"><span class="comment">//如何迅速算出a[i]离散化后对应的index：二分</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">//存储所有离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());<span class="comment">//去掉重复元素</span></span><br><span class="line"><span class="comment">//unique返回将重复元素移到最后的第一个重复元素的下标，从此开始到终止，全部删除。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分求出x对应离散化值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//找到第一个&gt;=x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(allss[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r+<span class="number">1</span>; <span class="comment">//+1表示从下标1开始映射，不加1表示从0开始映射。在a[]数组找相对位置，返回给数组b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>区间合并</p>
<ul>
<li><code>pair</code>排序优先左端点排序，再右端点排序</li>
<li>先将所有区间的端点按左端点排序（右端点也可以，处理稍微不同）</li>
<li>贪心算法，主要是3种情况，A与B线段有交集，A与B线段重合（设B小于A），A与B线段无交集</li>
<li>其中第一种和第二种可以合并为一种：更新尾边界为<code>max</code>A与B尾部。第二种则更新边界。</li>
<li>开局可设左右端点为正负无穷</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有存在交集的区间和并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector&lt;PII&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>()); <span class="comment">//默认按pair第一个first排序。</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>; <span class="comment">//开始设边界无穷小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg: segs)</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first) <span class="comment">//第一个右边界小于第二个左边界，则无交集,情况3</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">puh_back</span>(&#123;st, ed&#125;); <span class="comment">//!=-2e9确保开始的输入正确。</span></span><br><span class="line">            st = seg.first;</span><br><span class="line">            ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);<span class="comment">//第1，2种情况，更新尾边界</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);<span class="comment">//确保不是输入为空（最边界），将最后一组区间放入。</span></span><br><span class="line">    </span><br><span class="line">    segs = res; <span class="comment">//放回。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法板子</category>
      </categories>
  </entry>
  <entry>
    <title>技巧</title>
    <url>/2024/03/19/%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="字符串部分技巧"><a href="#字符串部分技巧" class="headerlink" title="字符串部分技巧"></a>字符串部分技巧</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串大小写转换：</span></span><br><span class="line"><span class="comment">//可以使用std库函数std::tolower来将大写转换为小写。相应的，对于字符操作，也存在std::tolower、std::toupper</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//空格字符&#x27; &#x27; ASCII = 32,而大小写字母刚好差32，小写字母的ASCII大于大写字母的ASCII</span></span><br><span class="line"><span class="comment">//常用字母 异或 空格字符来大小写转换，eg：</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(c &amp; <span class="string">&#x27; &#x27;</span>); <span class="comment">//判断是否为小写</span></span><br><span class="line"><span class="keyword">if</span>(~c &amp; <span class="string">&#x27; &#x27;</span>); <span class="comment">//判断是否为大写,~为取反码</span></span><br><span class="line">c |=<span class="string">&#x27; &#x27;</span>; <span class="comment">//转换为小写，等价于std::tolower</span></span><br><span class="line">c ^=<span class="string">&#x27; &#x27;</span>; <span class="comment">//大小写相互转换</span></span><br><span class="line">c = (c | <span class="string">&#x27; &#x27;</span>) ^ <span class="string">&#x27; &#x27;</span>; <span class="comment">//转换为大写字母，等价于std::toupper</span></span><br></pre></td></tr></table></figure>

<hr>
<span id="more"></span>

<h3 id="无穷量技巧"><a href="#无穷量技巧" class="headerlink" title="无穷量技巧"></a>无穷量技巧</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">在算法竞赛中，我们常常需要用到设置一个常量用来代表“无穷大”。</span><br><span class="line"></span><br><span class="line">比如对于<span class="type">int</span>类型的数，有的人会采用INT_MAX，即<span class="number">0x7fffffff</span>作为无穷大。但是以INT_MAX为无穷大常常面临一个问题，即加一个其他的数会溢出。</span><br><span class="line"></span><br><span class="line">而这种情况在动态规划，或者其他一些递推的算法中常常出现，很有可能导致算法出问题。</span><br><span class="line"></span><br><span class="line">所以在算法竞赛中，我们常采用<span class="number">0x3f3f3f3f</span>来作为无穷大。<span class="number">0x3f3f3f3f</span>主要有如下好处：</span><br><span class="line"></span><br><span class="line"><span class="number">0x3f3f3f3f</span>的十进制为<span class="number">1061109567</span>，和INT_MAX一个数量级，即<span class="number">10</span>^<span class="number">9</span>数量级，而一般场合下的数据都是小于<span class="number">10</span>^<span class="number">9</span>的。</span><br><span class="line"><span class="number">0x3f3f3f3f</span> * <span class="number">2</span> = <span class="number">2122219134</span>，无穷大相加依然不会溢出。</span><br><span class="line">可以使用<span class="built_in">memset</span>(array, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(array))来为数组设初值为<span class="number">0x3f3f3f3f</span>，因为这个数的每个字节都是<span class="number">0x3f</span>。</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="字符函数库cctype"><a href="#字符函数库cctype" class="headerlink" title="字符函数库cctype"></a>字符函数库<code>cctype</code></h3><ul>
<li>C++从C语言继承了一个与字符相关的、非常方便的函数软件包， 它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这 些函数的原型是在头文件<code>cctype</code>（老式的风格中为<code>ctype.h</code>）中定义的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（这些函数的返回类型为int，而不是bool，但通常bool转换让您能够将它们视为bool类型。）</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">isalpha</span>(ch); <span class="comment">//如果是字符返回非零值，，else返回0</span></span><br><span class="line"><span class="built_in">ispunct</span>(ch); <span class="comment">//如果是标点符号，返回非零值</span></span><br><span class="line"><span class="built_in">isdigits</span>(ch); <span class="comment">//判断是否为数字字符</span></span><br><span class="line"><span class="built_in">isspace</span>(ch); <span class="comment">//判断是否尾空白字符：换行，空格，制表符</span></span><br><span class="line"><span class="built_in">isalnum</span>(ch); <span class="comment">//判断是否是字母或数字</span></span><br><span class="line"><span class="built_in">iscntrl</span>(ch); <span class="comment">//判断是否是控制字符</span></span><br><span class="line"><span class="built_in">isgraph</span>(ch); <span class="comment">//判断是否是除了空格之外的打印字符</span></span><br><span class="line"><span class="built_in">islower</span>(ch); <span class="comment">//判断小写</span></span><br><span class="line"><span class="built_in">isupper</span>(ch); <span class="comment">//判断大写</span></span><br><span class="line"><span class="built_in">isprint</span>(ch); <span class="comment">//判断参数是不是打印字符（包含空格）</span></span><br><span class="line"><span class="built_in">isxdigit</span>(ch); <span class="comment">//判断参数是16进制数范围内：0~9,a~f或A~F</span></span><br><span class="line"><span class="built_in">tolower</span>(ch); <span class="comment">//变小写</span></span><br><span class="line"><span class="built_in">toupper</span>(ch); <span class="comment">//变大写</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法板子</category>
      </categories>
  </entry>
  <entry>
    <title>搜索</title>
    <url>/2024/03/19/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<ul>
<li>深搜与广搜 区别①广搜定义结构体，求step，深搜回溯求</li>
<li>广度搜索优先：</li>
<li>经典走迷宫：(起点到终点，求最短路，若有条件限制，还需要优化，可设置一个数组？存储步数，当再次走过该点，比较，选择最优路)</li>
</ul>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> maze[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> book[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;<span class="comment">//上下左右四个坐标 走向</span></span><br><span class="line"><span class="type">int</span> n, m; </span><br><span class="line"></span><br><span class="line"><span class="comment">//坐标存储进入队列，步数也存入 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">stayin</span><span class="params">(<span class="type">int</span> tx, <span class="type">int</span> ty)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">position</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y, step;</span><br><span class="line">	<span class="built_in">position</span>(<span class="type">int</span> px, <span class="type">int</span> py, <span class="type">int</span> pstep): <span class="built_in">x</span>(px), <span class="built_in">y</span>(py), <span class="built_in">step</span>(pstep)&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy)</span> </span>&#123;</span><br><span class="line">	queue&lt;position&gt; que;<span class="comment">//存储 </span></span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">position</span>(sx, sy, <span class="number">0</span>));<span class="comment">//起点入队</span></span><br><span class="line">	book[sx][sy] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//开始每个出入队，遍历所有结点 </span></span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> x = que.<span class="built_in">front</span>().x;<span class="comment">//获取当前坐标与步数 </span></span><br><span class="line">		<span class="type">int</span> y = que.<span class="built_in">front</span>().y;</span><br><span class="line">		<span class="type">int</span> step = que.<span class="built_in">front</span>().step;</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="comment">//开始四个方向走一波 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			<span class="type">int</span> tx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">			<span class="type">int</span> ty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">			<span class="comment">//越界，非障碍，未走过 </span></span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">stayin</span>(tx,ty)&amp;&amp;maze[tx][ty]!=<span class="string">&#x27;#&#x27;</span>&amp;&amp;!book[tx][ty]) &#123;</span><br><span class="line">				<span class="keyword">if</span>(maze[tx][ty] == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> step+<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//如果上面外if都满足，且不是终点</span></span><br><span class="line">				q.<span class="built_in">push</span>(<span class="built_in">position</span>(tx, ty, step+<span class="number">1</span>));</span><br><span class="line">				book[tx][ty] =<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//遍历所有，都到不了终点 </span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sx sy;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="comment">//cin&gt;&gt;maze[i];//也可，行的列，当作string输入 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">			cin&gt;&gt;maze[i][j];</span><br><span class="line">			<span class="keyword">if</span>(maze[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">				sx = i;</span><br><span class="line">				sy = j;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="built_in">bfs</span>(sx,sy);<span class="comment">//输出步数 </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>深度优先搜索</li>
<li>经典走迷宫：（起点走迷宫，搜索全路径，找到通路，修改一下，可求最短路，需要比较min，优化）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//这是设定的状态转移变量，分为上下左右4组，每一组的值分别代表X,Y的偏移</span></span><br><span class="line"><span class="type">int</span> dst[<span class="number">4</span>][<span class="number">2</span>]=&#123;<span class="comment">//上下左右 </span></span><br><span class="line">                <span class="number">-1</span>,<span class="number">0</span>,</span><br><span class="line">                <span class="number">1</span>,<span class="number">0</span>,</span><br><span class="line">                <span class="number">0</span>,<span class="number">-1</span>,</span><br><span class="line">                <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">              &#125;; </span><br><span class="line"><span class="comment">//迷宫，终点设置为数字3，已经走过的节点设置为4，测试样例</span></span><br><span class="line"><span class="type">int</span>  maze[<span class="number">5</span>][<span class="number">5</span>] = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(maze[x][y]==<span class="number">3</span>)<span class="comment">//判断是否走到了终点，走到了就是输出找到的解</span></span><br><span class="line">    &#123;<span class="comment">//if里面是对可行解的一个判断表达式，里面的话就执行我们得到一个解后要进行的操作。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;maze[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)<span class="comment">//枚举转移状态</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> nextx = x+dst[i][<span class="number">0</span>];<span class="comment">//计算转移状态</span></span><br><span class="line">        <span class="type">int</span> nexty = y+dst[i][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//下面这里就是DFS的核心部分了，判断转移是否合法，合法的递归进去，不合法的，不进行搜索，if需要包含全部判断条件，不可缺一，否则搜索回出问题</span></span><br><span class="line">        <span class="keyword">if</span>(nextx&gt;=<span class="number">0</span> &amp;&amp; nextx&lt;=<span class="number">4</span> &amp;&amp; nexty&gt;=<span class="number">0</span> &amp;&amp; nexty&lt;=<span class="number">4</span>&amp;&amp;(maze[nextx][nexty]!=<span class="number">1</span>)&amp;&amp;(maze[nextx][nexty]!=<span class="number">4</span>))<span class="comment">//判断下一个要走的点是否合法，在迷宫的题目里面主要是判断转移的点能不能走 </span></span><br><span class="line">        &#123;</span><br><span class="line">            maze[x][y] = <span class="number">4</span>;<span class="comment">//设置当前点为走过   </span></span><br><span class="line">            <span class="built_in">dfs</span>(nextx,nexty);<span class="comment">//进一步搜索            </span></span><br><span class="line">            maze[x][y] = <span class="number">0</span>;<span class="comment">//退出来设置为没有走过，这样在回溯进行后续搜索时，不会影响对路径的搜索     </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//初始调用</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dfs求step：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> _map[<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//地图</span></span><br><span class="line"><span class="type">int</span> n, m, ans;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> book[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> sx, <span class="type">int</span> sy, <span class="type">int</span> step)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//递归终止条件，待会stack替代 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_map[sx][sy] == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">		ans = step;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> px = sx + dir[i][<span class="number">0</span>], py = sy + dir[i][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (px &gt;= <span class="number">0</span> &amp;&amp; px &lt; n &amp;&amp; py &gt;= <span class="number">0</span> &amp;&amp; py &lt; m &amp;&amp; _map[px][py] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; book[sx][sy] != <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//当前点标记 </span></span><br><span class="line">			book[sx][sy] = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//走到底 </span></span><br><span class="line">			<span class="built_in">dfs</span>(px, py, step + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//回溯</span></span><br><span class="line">			book[sx][sy] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sx, sy;</span><br><span class="line">	<span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">			cin &gt;&gt; _map[i][j];</span><br><span class="line">			<span class="keyword">if</span> (_map[i][j] == <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">				sx = i;</span><br><span class="line">				sy = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(sx, sy, step);</span><br><span class="line">	cout &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>搜索与图论</title>
    <url>/2024/03/19/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="树与图的相关模板代码"><a href="#树与图的相关模板代码" class="headerlink" title="树与图的相关模板代码"></a>树与图的相关模板代码</h3><ul>
<li><p>树与图的存储：</p>
<ul>
<li><p>邻接矩阵（略），浴帘上课讲的即是。</p>
</li>
<li><p>邻接表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于每一个点k， 开一个单链表，存储k所有可以走到的点，h[k]存储这个单链表的头结点，即邻接表表头</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b; </span><br><span class="line">    ne[idx] = h[a]; <span class="comment">//头插法。</span></span><br><span class="line">    h[a] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in">sizeof</span>(h));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>树与图的遍历：$时复O(n+m)，n顶点数，m边数$</p>
<ul>
<li><p>深度优先</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vis[u] = <span class="literal">true</span>; <span class="comment">//vis[u]标记u已经走过</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>广度优先</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">vis[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">//一号结点已被遍历</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[j])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[j] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>topo</code>排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>; <span class="comment">//手写队列</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//d[i]存储i点入度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(d[i] &gt; <span class="number">0</span>)</span><br><span class="line">            q[++ tt] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt) <span class="comment">//手动模拟队列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh];</span><br><span class="line">        hh++;</span><br><span class="line">        <span class="comment">//邻接表版</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            d[j]--; </span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">0</span>) <span class="comment">//无入度，入队</span></span><br><span class="line">                q[++ tt] = j; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>; <span class="comment">//true则存在topo序列，false则不存在topo排序（存在回路，或连通分量）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
<li><p>无向图是特殊的有向图（连两条边），因此可用有向图直接套无向图。</p>
</li>
<li><p>朴素<code>dijkstra</code>算法：求正单源最短路,一般用于稠密图</p>
<ul>
<li><p>解决邻接矩阵正数边的自环和重边（a点到b点多条边：<code>g[a][b] = min(g[a][b],c),c为新的重边</code>，g初始化大小<code>0x3f3f3f3f</code>,自环在原点：显然大于0，自环在其他点，显然大于不再绕环走一圈的距离）。邻接表不需要，因为是链表，可以多连，而且本就是选最短路</p>
</li>
<li><p>时间复杂度：$O(n^2 + m)$</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">//存边</span></span><br><span class="line"><span class="type">int</span> dis[N]; <span class="comment">//存某号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> vis[N]; <span class="comment">//存每个点最短路已确定标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求1号-&gt;n号点的最短路，若不存在返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//默认从第一号开始，可修改</span></span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//到自身距离0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>; <span class="comment">//找未遍历的目前最短路下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; (t == <span class="number">-1</span> || dis[t] &gt; dis[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dis[j] = <span class="built_in">min</span>(dis[j], dis[t] + g[t][j]);</span><br><span class="line">        </span><br><span class="line">        vis[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt;= <span class="number">0x3f3f3f3f</span>/<span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不存在到1-&gt;n号点路径</span></span><br><span class="line">    <span class="keyword">return</span> dis[n]; <span class="comment">//返回到n号点最短距离。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>堆优化<code>dijkstra</code>算法：时间复杂度：$O(mlogn)$，一般用于稀疏图</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">//点数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边，//w存储权值，可以将所有重边，自环存下来（靠idx）</span></span><br><span class="line"><span class="type">int</span> dis[N];  <span class="comment">//存储所有点到k号点的距离</span></span><br><span class="line"><span class="type">bool</span> vis[N]; <span class="comment">//某个点最短距离是否一已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////求1号-&gt;n号点的最短路，若不存在返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//到自身距离0</span></span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class="comment">//小顶堆</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">//first距离，second存结点编号</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(vis[ver]) <span class="keyword">continue</span>; <span class="comment">//该点已遍历，因为该点可能有环啥的，顺序不同把，冗余备份，最多有m个元素（m条边）</span></span><br><span class="line">        vis[ver] = <span class="literal">true</span>; <span class="comment">//遍历。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver];  i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j] &gt; distance + w[i]) <span class="comment">//将所有最短路放入堆，最后取出最小的且未被走过</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dis[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>Bellman-Ford</code>算法：求含<strong>负边</strong>的单源最短路</p>
<ul>
<li><p>有边数限制的最短路，只能用<code>Bellman-Ford</code>算法，用<code>SPFA</code>不行</p>
<ul>
<li><code>需要添加一个backup数组备份原来的dis[],因为：内层循环的dis松弛，不是每次m次都做操作，但是边的变化，确是实在的。比如:1-&gt;2-&gt;3，dist[2]+w &lt;dist[3],仍会变，这叫串联，就导致，后面的第二条边，第三条边，在边数限制如1的情况下，用dist[2]+w（第二条边）去更新了最短路。突破了限制，从而可能导致在边数限制下的最短路大于突破后的最短路，从而min()不出大的最短路，导致结果错误</code></li>
<li>更新的时候只用上一次的结果，这样就不会发生串联了（此时迭代用：<code>min(dist[b], backup[a]+w）</code></li>
</ul>
</li>
<li><p>实现：遍历n个点（for循环n次），for循环所有边(a,b,w,即a-&gt;b权w。只要能用就行，不一定非要邻接表&#x2F;矩阵，结构体就行)，<code>dist[b] = min(dist[b], dist[a]+w)</code>（和dijkstra一样））</p>
</li>
<li><p>若有负权<strong>回路</strong>，负权边不一定存在（显然。绕多几圈，越绕越小，但是负环如果不在路径上，是不影响的）</p>
</li>
<li><p>时间复杂度$O(nm)，n为点数，m为边数$</p>
</li>
<li><p>松弛三角不等式：<code>dist[b] &lt;= dist[a]+w</code>该算法执行完之后，保证有该性质。</p>
</li>
<li><p>抽屉原理：3个点，3条边，说明肯定有条边是属于同一个点的，存在环（最短路：n个点，n-1条边，若n条边，则应该有n+1个点，而只有n个点，说明两个点是一样的。存在环，又边是更新后的，若每次更新都会加一条边，说明肯定存在负环）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意在下面的模板题中，需对本模板稍作修改，加上备份数组last。...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">//n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> dis[N]; <span class="comment">//存储1到x的最短路</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重，即a起点，b终点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="comment">//原本是n-1，为了判断负环，再加多一次，如果dis还会变（即还会松弛），则说明存在负环。</span></span><br><span class="line">    <span class="comment">//内层循环的dis松弛，不是每次m次都做操作，但是边的变化，确是实在的。比如:1-&gt;2-&gt;3，dist[2]+w &lt;dist[3],仍会变，这叫串联。前提是外层循环的i到哪了，i表示点数。i=0，表示更新一条边距离的（即与1直接相连的），1表示更新两条边距离的。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span>(dis[b] &gt; dis[a] + w)</span><br><span class="line">                dis[b] = dis[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dis[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>spfa</code>算法：<strong>队列</strong>优化的<code>Bellman-Ford</code>算法（队列，优先队列，堆都行）</p>
<ul>
<li><p>重边，自环都不影响。重边（邻接表会遍历，一直更新到最小），自环（true了该点，自环不了）</p>
</li>
<li><p><a href="https://blog.csdn.net/qq_35644234/article/details/61614581">最短路径问题—SPFA算法详解_1342:【例4-1】最短路径问题spfa-CSDN博客</a></p>
</li>
<li><p>spfa算法可以用于正权（即dijkstra处理的，spfa可以处理（可能存在不可以的)</p>
</li>
<li><p>不允许有<strong>负环</strong></p>
</li>
<li><p>即处理<code>dist[b] = min(dist[b], dist[a]+w)</code>,不是每次都会实现该步骤，所以，用优先队列，当取出以t为起点（前提是t变小了），更新t为起点到其他点的边权。更新的出点，入队（前提是队列中没有）（目的：到该点的距离松弛了，那么j点为起点到后面的路径检查一下是否可以松弛到更小。）</p>
</li>
<li><p>$时间复杂度：O(m)，最坏情况退化回ford算法O(nm)$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n; <span class="comment">//总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dis[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> vis[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//存这个点当前是否在队列中，若在，则再次有该点要进，不给进</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        vis[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j] &gt; dis[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[j] = dis[t] + w[i];</span><br><span class="line">                <span class="comment">//（目的：到该点的距离松弛了，那么j点为起点到后面的路径检查一下是否可以松弛到更小。）</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[j]) <span class="comment">//若队列中已存在j，则不需要将j重复插入。不存在则插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    vis[j] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if(dis[n] == 0x3f3f3f3f) return -1; //这个不需要&gt;=0x3f3f3f/2, 因为队列里都是由起点更新到的点，不存在bellman-ford算法中未更新的点同样被边更新的情况。</span></span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>spfa</code>算法判断图中是否存在负环（回路）</p>
<ul>
<li><p>$时间复杂度：O(nm)，n为点数，m为边数$</p>
</li>
<li><p>原理：若某条最短路径上有n个点（除了自己），那么加上自己后共有n+1个点，由抽屉原理，一定有两个点相同，所以存在环。</p>
<ul>
<li>1.求负权回路，主要是要看一个相对变小的状态，所以<strong>没必要</strong>初始化以求最短路精确值，重点是<strong>看到dist减小的趋势</strong>，所以与dist全零或是全无穷无关。2.因为我们检验的回路不一定以1号点为起点，<strong>所以要把他们都加进来</strong>。如果1与负环回路不连通，那么如果只以1为起点，根据spfa的原理，<strong>负环回路将得不到更新</strong>，从而判断失误<br>$$<br>判断负环：\<br>法1.开始算法前，调用拓扑排序进行判断（一般不采用，浪费时间）\<br>法2.如果点进入队列的次数超过N次则存在负环（N为图的顶点数）<br>$$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dis[N], cnt[N];  <span class="comment">//dis存储k号点到x号点的最短距离，cnt存储k到x的最短路中经过的点数</span></span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果存在负环， 返回true， 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//不需要初始化dis距离数组</span></span><br><span class="line">    <span class="comment">//原理：若某条最短路径上有n个点（除了自己），那么加上自己后共有n+1个点，由抽屉原理，一定有两个点相同，所以存在环。</span></span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">		q.<span class="built_in">push</span>(i);</span><br><span class="line">    	vis[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        vis[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j] &gt; dis[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">				dis[j] = dis[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;<span class="comment">//做不到提前判断出来负环。跟topo类似，topo也得等到队列遍历完，没到n个点才能判断存在环。</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//如果从1号点到x的最短路中包含至少 n个点（不包括自己），则说明存在环</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!vis[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    vis[j] = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>floyd</code>算法：求含（）的<strong>多源</strong>汇最短路</p>
<ul>
<li><p>不能有<strong>负环</strong>，用邻接矩阵</p>
</li>
<li><p>$时间复杂度O(n^3),n为点数$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        <span class="keyword">if</span>(i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">//算法结束后，d[a][b]表示a到b的最短路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)<span class="comment">//以某个点为中转站下，检查距离是否因为该点变小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>朴素<code>Prim</code>算法</p>
<ul>
<li><p>$时间复杂度O(n^2+m)，n为点数，m为边数$</p>
</li>
<li><p>优化版也是用堆优化。（数据结构课程讲的就是优化版）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dis[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> vis[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果图不连通，返回INF（值为0x3f3f3f3f），否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; (t == <span class="number">-1</span> || dis[t] &gt; dis[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dis[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i) res += dis[t];</span><br><span class="line">        vis[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            dis[j] = <span class="built_in">min</span>(dis[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>Kruskal</code>算法</p>
<ul>
<li><p>$时间复杂度O(mlogm)，n为点数，m为边数$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N]; <span class="comment">//并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;Ed) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; Ed.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        f[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != f[x]) f[x] = <span class="built_in">find</span>(f[x]);<span class="comment">//路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) </span><br><span class="line">    &#123;</span><br><span class="line">        f[x] = f[y];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;<span class="comment">//权值，点数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">merge</span>(a,b)) <span class="comment">//找到一个新的最短枝</span></span><br><span class="line">        &#123;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>染色法判别二分图（二部图）</p>
<ul>
<li><p>二部图：当仅不含奇数(顶点)环</p>
</li>
<li><p>遍历每一个点，该点的邻点都属于另一边（即同一边，不能有边相连）</p>
</li>
<li><p>$时间复杂度O(n + m)，n为点数，m为边数$</p>
</li>
<li><p>简单的dfs</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数：u为当前节点，c为当前点的 颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	color[u] = c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(color[j] == <span class="number">-1</span>) <span class="comment">//未染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dis</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="built_in">sizeof</span>(color));</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(color[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>匈牙利算法</p>
<ul>
<li><p>二分图最大匹配问题（即二分图左右部分匹配的点数最大数量(左右每个点唯一匹配)）</p>
</li>
<li><p>左部图某些点与右部图某些点相连，假设，左某点与右某点<strong>关联</strong>（前提是它们有连线），检查右该点是否<strong>已被左该点之前的点所关联</strong>：若没有则该左右点<strong>真关联</strong>；若已被关联，则检查右该点被关联的左某点是否与其他右点有连线（即是否可以改变真关联），若检查了都没有那就只能放弃。继续遍历下一个左某点</p>
</li>
<li><p><code>时间复杂度O(nm)，n为点数，m为边数</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> vis[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!vis[j])</span><br><span class="line">        &#123;</span><br><span class="line">			vis[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个点的集合</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法板子</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2024/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>便捷操作:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//其中p和s都是字符数组</span></span><br><span class="line"><span class="comment">//&gt;&gt; p + 1: 从标准输入读取字符数据，并将其存储在字符数组 p 的第二个位置开始（p + 1），而不是第一个位置。这通常用于跳过第一个位置，可能是因为数组的第一个位置已经有了初始值或者其他数据。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>单链表板子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在链头插入一个数x(头插法)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a; </span><br><span class="line">    ne[idx] = head; <span class="comment">//即ne存索引。</span></span><br><span class="line">    head = idx;<span class="comment">//新头</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除头节点，需要保证头节点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>


</li>
<li><p>双链表(指向前驱与后继)，即双向链表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//0是头，1是尾</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//所以0号点的右边指向尾，1号点的左边指向头。可以自己修改。</span></span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在结点a的右边插入一个数字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a; <span class="comment">//即左指针指向a结点下标</span></span><br><span class="line">    r[idx] = r[a];<span class="comment">//即右指针指向a结点下一个结点下标</span></span><br><span class="line">    l[r[a]] = idx;<span class="comment">//即a结点的下一个指针的左指针指向插入节点。</span></span><br><span class="line">    r[a] = idx;<span class="comment">//即a结点的右指针指向插入节点。</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶插入一个数字， 0号单元不存</span></span><br><span class="line">skt[++tt] = x; </span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶弹出数字</span></span><br><span class="line">tt--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈顶值</span></span><br><span class="line">skt[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="keyword">if</span>(tt&gt;<span class="number">0</span>) &#123;&#125;<span class="comment">//不空</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果 hh &lt;= tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>循环队列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果hh != tt，则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>单调栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常见模型：找出每个数左边距离它 最近的 比它大/小的数字</span></span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line">forr(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt--; <span class="comment">//找到栈中第一个大于/小于[i]的元素，将i插入栈顶，形成新的单调</span></span><br><span class="line">    stk[++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>单调队列（存下标，单调队列，这样最好判断，不然假设最小&#x2F;大值在中间。）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常见模型：找出滑动窗口中的最大值/最小值</span></span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) h++;<span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) t--;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">    <span class="comment">//操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>KMP</code></p>
<ul>
<li><p>即：将模式串P与长文本S匹配，当P匹配到j+1与S的i不等时，j回溯到ne[j]，即相同的最长前缀的尾，继续j+1与S的i匹配。</p>
</li>
<li><p>若一直匹配都不成功，j会一直回溯到j&#x3D;0，即从头开始匹配。</p>
</li>
<li><p>若回溯与否（即，进行上面检查操作后，匹配j+1与i成功，则j++。）</p>
</li>
<li><p>当j&#x3D;&#x3D;m，即将模式串P在S中全部匹配完毕，则，可输出结果等操作，若要反复找出所有匹配成功位置，则继续上面操作，j &#x3D; ne[j]，找回最长公共前缀点，继续j+1与i匹配。</p>
</li>
<li><p>对于<code>Next[N];//ne[N]</code>数组，处理方式与上面一样，只对模式串P，取i；j&#x3D;0，然后匹配，递归操作，直到匹配为止。其中的ne[i]  &#x3D; j，表示，该处的最长公共前缀为j处。（即已经进行了上面的操作了）。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串， n是s的长度，m是p的长度,求模式串的Next数组：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j ++;</span><br><span class="line">    <span class="keyword">if</span>(j==m)<span class="comment">//这个不用变，当从1变成0开始（起始位置），不影响这个。其余的p[j+1]--&gt;p[j], ne[j] --&gt;n[j-1]</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">//匹配成功后的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>Trie</code>树（前缀树，字典树）</p>
<ul>
<li>标记<code>cnt[]</code>用于记录，以该字母结尾的字符串的个数。如果我要<strong>查找</strong>：有一个字符串如：abc，也有这么一条分支：abcd，但是原先预处理的字符串里没有abc，即以c结尾的<code>cnt</code>，那么<strong>也是查找不到</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">//0号点是根节点也是空结点，不存放字母</span></span><br><span class="line"><span class="comment">//son[][]存储树中每个节点的子结点</span></span><br><span class="line"><span class="comment">//cnt[] 存储以每个结点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//son[p][u] ---&gt; p父u儿</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) <span class="comment">//结尾字符默认str[i] = &#x27;\0&#x27;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++ idx;<span class="comment">//没有以该字母为此位置的结点，则添加。每层一个节点。（id）</span></span><br><span class="line">        p = son[p][u]; <span class="comment">//往子树走。</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++; <span class="comment">//以该字母结尾的字符串数量+1。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//没有该字符串</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p]; <span class="comment">//p最终指向最后一个字母的位置。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>并查集</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//朴素并查集</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">//father</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0 or 1 开始，自己决定。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//if(p[x] != x) p[x] = find(p[x]);</span></span><br><span class="line">    <span class="comment">//return p[x];</span></span><br><span class="line">    <span class="keyword">return</span> x == p[x]? x : <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x != y) p[x] = p[y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//维护size的并查集</span></span><br><span class="line"><span class="type">int</span> p[N], size[N]; </span><br><span class="line"><span class="comment">//size[]只有祖宗结点的才有意义，表示祖宗结点所在集合中的点的数量，即统计该集合下的元素个数。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//假定编号从1~n。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        size[i] = <span class="number">1</span>;<span class="comment">//每个独立元素集合开始为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = <span class="built_in">find</span>(x); y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)</span><br><span class="line">    &#123;</span><br><span class="line">        size[y] += size[x]; <span class="comment">//x祖先归属到y祖先</span></span><br><span class="line">        p[x] = p[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//路径压缩：包含合并优化:即降低树的高度（用if判长）</span></span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">//d[x]存储x到p[x]的距离，p[]存储每个点的祖宗结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)<span class="comment">//非祖宗</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]]; <span class="comment">//求距离。</span></span><br><span class="line">        p[x] = u; <span class="comment">//路径压缩，每个点都挂到最终祖先商。每一次的p[x]都为u祖先，然后返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];<span class="comment">//不可返回x，因为x不是祖宗，返回f[x]才是祖宗</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x); y = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y) p[x] = p[y];</span><br><span class="line">    d[x] = dis;<span class="comment">//根据具体问题，初始化find(x)的偏移量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[l]存储堆中下标是l的点是第几个插入的,即hp-&gt;ph(映射)</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个点以及其映射关系（即堆调整）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a],hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向下调整堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u*<span class="number">2</span>; <span class="comment">//即儿子小于父亲，最小堆。</span></span><br><span class="line">    <span class="keyword">if</span>(u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u*<span class="number">2</span>+<span class="number">1</span>; <span class="comment">//左右孩子选小的</span></span><br><span class="line">    <span class="keyword">if</span>(u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向上调整堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结点从1开始，父亲结点不为0，且儿子小于父亲。</span></span><br><span class="line">    <span class="keyword">while</span>(u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u/<span class="number">2</span>]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u/<span class="number">2</span>);</span><br><span class="line">        u /= <span class="number">2</span>; <span class="comment">//儿子父亲向上调整</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//O(n)建堆,向下调整</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--) <span class="built_in">down</span>(i);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第k个节点：</span></span><br><span class="line">hp[k] = hp[size];size--;<span class="built_in">down</span>(k),<span class="built_in">up</span>(k);<span class="comment">//即将最后一个元素与第k个交换后，新的第k个元素，要么过大，要么过小，则执行down和up，只有一个执行（要么偏大，下沉，偏小上浮。）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改第k个元素</span></span><br><span class="line">hp[k] = x ; <span class="built_in">down</span>(k),<span class="built_in">up</span>(k);<span class="comment">//修改了也是，上浮下沉选一个。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>一般哈希：<strong>拉链法</strong>，<strong>开放寻址法</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拉链</span></span><br><span class="line"><span class="type">int</span> haed[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向哈希表插入一个数字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> k = (x % N + N) % N; <span class="comment">//求地址，X%N+N确保为自然数。</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k]; <span class="comment">//头插法</span></span><br><span class="line">    h[k] = idx; <span class="comment">//头插法，第k号表的头结点</span></span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="comment">//tail结点ne[i]=-1，见最上链表初始化。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开放寻址法</span></span><br><span class="line"><span class="type">int</span> h[N];<span class="comment">//长度一般开到题目的2~3倍，减少冲突</span></span><br><span class="line"><span class="comment">//若x在哈希表中，返回x下标，若x不在哈希表中，返回x应该插入的位置。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[t] != null &amp;&amp; h[t] != x)<span class="comment">//null自定值。甚么时候为空，eg:null=INT32_MAX....</span></span><br><span class="line">    &#123;</span><br><span class="line">        t++;</span><br><span class="line">        <span class="keyword">if</span>(t == N) t = <span class="number">0</span>; <span class="comment">//即t冲突一直到N，但是0~N-1，所以求模循环到0继续找。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;<span class="comment">//上面，不存在无限循环，因为数组容量开的大于题目范围。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>字符串哈希：<strong>进制哈希</strong></p>
<ul>
<li>快速判断两个字符串是否相等（哈希值相等），比KMP还快。</li>
<li>可用的题目方面例题如：</li>
<li><img src="/.com//03/19/数据结构/undefined" alt="image-20240124172550213" style="zoom:50%;"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将字符串看成P进制数，P一般取素数。常用的冲突概率低的数为：131，13331.</span></span><br><span class="line"><span class="comment">//取模用2^64，直接用unsigned long long 存储，溢出后的结果就是取模的结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; </span><br><span class="line"><span class="comment">//h[k]存储字符串前K个字母的哈希值，p[K]存储 p^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i<span class="number">-1</span>]* P + str[i];</span><br><span class="line">    p[i] = p[i<span class="number">-1</span>] * P;<span class="comment">//大P为进制数，小p</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算子串 str[l~r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//举例子：求abcde中的de，则：h[abcde] - h[abc]*p^2(即要左移k位，对齐)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>算法板子</category>
      </categories>
  </entry>
  <entry>
    <title>数论</title>
    <url>/2024/03/18/%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="筛法的原理"><a href="#筛法的原理" class="headerlink" title="筛法的原理"></a>筛法的原理</h3><ul>
<li><p>质因数分解：任何大于 1 的正整数都能 唯一 的分解为有限个质数的乘积。根据这一定理任何一个合数都可以被分解成几个质数相乘的形式。</p>
<ul>
<li><p>可用于：求解约数个数，约数的和。因为某个正整数的约数也肯定等于质因数分解后的不同幂的乘积。</p>
</li>
<li><p>方法一(试除法，效率一般)：如360：360&#x2F;2 &#x3D; 180&#x2F;2 &#x3D; 90&#x2F;2 &#x3D; 45&#x2F;3 &#x3D; 15&#x2F;3 &#x3D; 5; 所以360的质因数乘积为2^3 * 3^2 * 5^1; 则其约数共有（3+1）（2+1）（1+1）&#x3D; 24个，即0-k次幂。</p>
<ul>
<li>试除法，可以把遍历范围改为<code>i &lt;= sqrt(n)</code>,因为有且最多有1个质因数大于合数的根号。证明：假设有俩质因数p1, p2大于sqrt(n),则 p1*p2 &gt; √n * √n &#x3D; n 。矛盾</li>
</ul>
</li>
<li><p>方法二：对于每个数，其约数总是成对出现的，比如 12 &#x3D; 3 * 4 &#x3D; 2 * 6….. 所以，我们只需要遍历到 (i &#x3D; 2; i * i &lt;&#x3D; n; i++)即可。唯一要注意的点就是，若 i * i &#x3D; n; 则只有一个约数，比如 25 &#x3D; 5^2</p>
</li>
<li><p><strong>题种三</strong>（欧拉筛求最小质因数+素数）：见代码：欧拉筛法部分，将vis改为记录素数即可，将vis的倍数被prime赋值（最小质因数）即可。</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>如本题：求一个正整数的约数的个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//法1：质因数分解</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n % i == <span class="number">0</span>) <span class="comment">// 缩小n，加快速度，毕竟如 360 = 2^3 * 3^2 * 5^1, 当除了3次2，则剩下的数就缩小了。注：肯定都是质数，因为如4，已经被2除过了，所以%4 != 0, 即合数都不可能出现，已被拆分为质数了</span></span><br><span class="line">    &#123;</span><br><span class="line">      tmp++;</span><br><span class="line">      n /= i;<span class="comment">//缩小</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans *= (tmp + <span class="number">1</span>);<span class="comment">//+1是因为0次幂</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n != <span class="number">1</span>)</span><br><span class="line">    ans *= (<span class="number">1</span>+<span class="number">1</span>); <span class="comment">//最后一个质数，比如上面的5，单独的</span></span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//法2：暴力求解 i*i &lt;= n</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  int main()</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    int n;</span></span><br><span class="line"><span class="comment">    int ans = 0;</span></span><br><span class="line"><span class="comment">    cin&gt;&gt;n;</span></span><br><span class="line"><span class="comment">    for(int i = 2; i*i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      if( n % i == 0)//找约数,加法，不存在合数被质数拆分</span></span><br><span class="line"><span class="comment">        ans += 2;</span></span><br><span class="line"><span class="comment">      if( i * i == n)</span></span><br><span class="line"><span class="comment">        ans--;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;ans;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>题2：求约数之和; 原本的拆分质因数公式就是：y &#x3D; p1^k * p2^m * p3^n * ….</p>
</li>
<li><p>即约数之和可以写为：(p1^0 + p1^1 + … + p1^k) * (p2^0 + p2^1 +…..+ p2^m) <em>…..</em>(P.^0 + ……+ p.^y); <code>约数的每一个次幂都出现的乘积和</code></p>
<ul>
<li>进一步化简公式就是：等比数列求和: a1[p1^(k+1) - 1]&#x2F;(p1 - 1) * ….(p !&#x3D; 1; 其中的a1就是p1^0，首项，为1)</li>
<li>代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>( <span class="type">int</span>  i = <span class="number">2</span>; i*i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">       <span class="type">int</span> tmp = i;</span><br><span class="line">       <span class="keyword">while</span>( n % i == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           tmp *= i;</span><br><span class="line">           n /= i;</span><br><span class="line">       &#125;</span><br><span class="line">       ans *= (tmp - <span class="number">1</span>) / (i - <span class="number">1</span>);<span class="comment">//a1=1</span></span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">if</span>(n != <span class="number">1</span>)</span><br><span class="line">       ans *= (n + <span class="number">1</span>); <span class="comment">// 因为（n^2 -1）/(n-1)</span></span><br><span class="line">   cout&lt;&lt;ans;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>题3：求模数：给定两个整数a, b; 问有多少个x，使得满足等式a mod x &#x3D; b,  如果存在无限个，输出”infinity”, 否则输出满足条件x的个数。</p>
</li>
<li><p>解析如下：</p>
<ul>
<li><p>如果a&#x3D;&#x3D;b , 只要mod的x大于a或b，肯定有无数个，比如 3 mod 4&#x2F;5&#x2F;6&#x2F;7…. &#x3D; 3</p>
</li>
<li><p>如果a&lt;b, 则不存在mod x使得 等于b 为0</p>
</li>
<li><p>如果a&gt;b, 则求(a - b) mod x &#x3D;&#x3D; 0 , 那么只要对(a - b)取约数，只要找到 i &lt; b, 则+1，其中i从1开始。约数成对出现，要保证其另一个约数也大于b，则再++（并且该约数不能 (a - b) &#x2F; i &#x3D; i）</p>
</li>
<li><p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(a == b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;infinity&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( a &lt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a -= b;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= a; i++) <span class="comment">//从一开始，不是完全素数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; b) ans++;</span><br><span class="line">            <span class="keyword">if</span>(a / i &gt; b &amp;&amp; a / i != i) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>题四:数树：在第一象限的坐标系中，若某点与（0，0）连线成的树没有被其他树覆盖，就称该树是可见的。比如：（5，3）可见，（4，2）不可见，因为被（2，1）覆盖。请计算n*n范围内可见树</p>
<ul>
<li><p>题解：n&#x3D;(0,2000),c&#x3D;(0,10)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//即a mod b == 1 ; b mod a == 1; 即最大公约数为1即可见。否则有约数都会被约数更小覆盖。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x%y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cin&gt;&gt;c;<span class="comment">//测试数据组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">gcd</span>(k, j) == <span class="number">1</span>)</span><br><span class="line">                    ans++; </span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans+<span class="number">2</span>&lt;&lt;endl;<span class="comment">//不要忘了坐标轴的两条树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>哥德巴赫猜想：任何一个偶数可以拆成两个质数之和。（奇数可以拆成质数和偶数之和，偶数如果为2则也为奇数，如果&gt;2,则也可以拆成两个质数）</p>
<ul>
<li><p>相关题目：交税，税收是n收入的最大因子（不包含本身n的因子），为了减少税钱，把n拆成多份，使得交的钱最少</p>
</li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prime</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i*i &lt;= num; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num %i== <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">prime</span>(n))   cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (n %<span class="number">2</span>==<span class="number">0</span>)  cout &lt;&lt; <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">prime</span>(n - <span class="number">2</span>))  cout &lt;&lt; <span class="number">2</span>;<span class="comment">//n-2如果等于质数，则为质数+2（质数），则只要交最大因子，各为1，共2，如果不是，则下面的输出，大于2的偶数拆成2个质数。</span></span><br><span class="line">   <span class="keyword">else</span>   cout &lt;&lt; <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>素数筛法</p>
<ul>
<li><p>埃氏筛法（O(nloglogn)</p>
<ul>
<li><p>对初始的队列{1，2，3,….,n},进行以下操作:</p>
<ul>
<li>输出最小素数2，然后筛掉2的倍数</li>
<li>输出最小素数3，然后筛掉3的倍数</li>
<li>输出最小素数5，然后筛掉5的倍数</li>
<li>……..</li>
</ul>
</li>
<li><p>一直重复以上步骤，直到队列为空。</p>
</li>
<li><p>下面给出代码：visit[i]用于记录数i的状态，visit[i] &#x3D; true表示被筛掉了,不是素数。prime[]存放素数，如prime[0]是第一个素数2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>; <span class="comment">//定义空间，可根据题目改动</span></span><br><span class="line"><span class="type">int</span> prime[N + <span class="number">1</span>]; <span class="comment">//存储素数，记录visit[i] = false的项</span></span><br><span class="line"><span class="type">bool</span> visit[N + <span class="number">1</span>]; <span class="comment">// true表示被筛掉</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">E_sieve</span><span class="params">(<span class="type">int</span> n)</span>  <span class="comment">//埃式筛法，算2-n之间的素数</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="type">int</span>  k = <span class="number">0</span>; <span class="comment">//统计素数个数</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) visit[i] = <span class="literal">false</span>; <span class="comment">// 初始化</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;=n; i++) <span class="comment">//从第一个素数2开始 （1）优化</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[i])</span><br><span class="line">        &#123;</span><br><span class="line">           prime[k++] = i; <span class="comment">//i是素数，存储到prime中</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)  <span class="comment">//i的倍数，都不是素数，筛掉。（2）优化</span></span><br><span class="line">                visit[j] = <span class="literal">true</span>;  <span class="comment">//标记为非素数</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> k;  <span class="comment">//返回素数的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>可优化（1），（2）；（1）处，做筛出的数字2，3，5，…，√n（根号n）就可以了。因为非素数k一定可以被一个小于或等于√n的素数整除，被筛出。</p>
</li>
<li><p>（2）处，j &#x3D; 2 * i，可改为j &#x3D; i * i，因为如i &#x3D; 5，则2 * 5，3 * 5，4 * 5，已经筛出过了</p>
</li>
<li><p>优化后算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">E_sieve</span><span class="params">(<span class="type">int</span> n)</span>  <span class="comment">//埃式筛法，算2-n之间的素数</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="type">int</span>  k = <span class="number">0</span>; <span class="comment">//统计素数个数</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) visit[i] = <span class="literal">false</span>; <span class="comment">// 初始化</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++) <span class="comment">//优化为sqrt</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[i])</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j = i * i; j &lt;= n; j += i)  <span class="comment">//i的倍数，都不是素数，筛掉，优化为i*i</span></span><br><span class="line">                visit[j] = <span class="literal">true</span>;  <span class="comment">//标记为非素数</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!visit[i]) prime[k++] = i;<span class="comment">//存储素数</span></span><br><span class="line">     <span class="keyword">return</span> k;  <span class="comment">//返回素数的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>欧拉筛法（O(n)，是线性筛。更优于埃式筛法）</p>
<ul>
<li><p>原理：每一个合数肯定有一个最小质因数；让每个合数只被它的最小质因数筛选一次，以达到不重复筛的目的。</p>
</li>
<li><p>具体操作：（1）逐一检查2-n之间的所有数，第一个检查的是2，是第一个素数；（2）当检查到第i个数时，利用已经求得的素数去筛掉对应的合数x，而且是用x的最小质因数去筛。</p>
</li>
<li><p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> prime[N]; <span class="comment">//保存素数，节约空间的话可缩小大小</span></span><br><span class="line"><span class="type">bool</span> vis[N]; <span class="comment">//记录是否被筛</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_sieve</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">//欧拉筛，返回素数的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 记录素数个数</span></span><br><span class="line">   <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)); <span class="comment">// 初始化</span></span><br><span class="line">   <span class="built_in">memset</span>(prime,<span class="number">0</span>,<span class="built_in">sizeof</span>(prime)); <span class="comment">// 初始化</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="comment">// 检查每个数，删除其中的合数</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[i]) prime[cnt++] = i; <span class="comment">// 如果没有筛过，是素数，记录；第一个素数为2</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)  <span class="comment">//用已经得到的素数去筛出后面的数</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span>(i * prime[j] &gt; n) <span class="keyword">break</span>; <span class="comment">//只筛选小于或等于n的数字</span></span><br><span class="line">         vis[i * prime[j]] = <span class="number">1</span>; <span class="comment">//关键1：用x的最小质因数筛去x</span></span><br><span class="line">         <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//关键2：如果不是这个数的最小质因数，则结束。</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>模板题：求出[1,n]之间的质数率（质数占比）</p>
</li>
<li><p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_sieve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//记录素数个数</span></span><br><span class="line">    <span class="comment">//memset(prime, 0, sizeof(prime));</span></span><br><span class="line">    <span class="comment">//memset(vis, 0, sizeof(vis));</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime[cnt++] = i;<span class="comment">//记录素数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)<span class="comment">//用前面的素数筛掉后面的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime[j] &gt; n) <span class="keyword">break</span>; <span class="comment">//排除掉大于n的数字</span></span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>; <span class="comment">//最小质因数筛掉合数</span></span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//避免重复筛，提前退出，比如12，又被2筛，被3筛</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//欧拉筛</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); </span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    count = <span class="built_in">euler_sieve</span>(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, (<span class="type">double</span>)count / n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="筛法的思想与应用"><a href="#筛法的思想与应用" class="headerlink" title="筛法的思想与应用"></a>筛法的思想与应用</h4><ul>
<li><p>给你t个数字，如果这个数X是喜欢数，则输出下一个喜欢数；如果这个数X不是喜欢数，输出-1。（0默认不是喜欢数）</p>
<ul>
<li><p>条件1：7的倍数都不是喜欢数（包含7）</p>
</li>
<li><p>条件2：数字中任一位含有7的倍数都不是喜欢数（包含该数）</p>
</li>
<li><p>数据范围：1&lt;&#x3D; t &lt;&#x3D; 2e5; 0 &lt;&#x3D; X &lt;&#x3D; 1e7;</p>
</li>
<li><p>例解c++：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>;</span><br><span class="line"><span class="type">int</span> like[N];</span><br><span class="line"><span class="type">bool</span>  vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( number &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(number % <span class="number">10</span> == <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        number /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>; <span class="comment">// 索引，返回数字查找下一个喜欢数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">// 已经遍历了最小倍数，防止出错</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i)) <span class="comment">// 检索所有</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= N; j += i)</span><br><span class="line">                vis[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            like[cnt++] = i;</span><br><span class="line">            cnt = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">my_sieve</span>();</span><br><span class="line">    <span class="type">int</span> t, num;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        <span class="keyword">if</span>(vis[num] || num == <span class="number">0</span>) cout&lt;&lt; <span class="number">-1</span> &lt;&lt;endl; <span class="comment">// 卡常0</span></span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;like[num]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数论板子</title>
    <url>/2024/03/19/%E6%95%B0%E8%AE%BA%E6%9D%BF%E5%AD%90/</url>
    <content><![CDATA[<h3 id="数学小知识集合"><a href="#数学小知识集合" class="headerlink" title="数学小知识集合"></a>数学小知识集合</h3><p>$$<br>1.\textbf{求所有元素的最大公约数}\<br>假设数组中的数分别为 a1, a2, …, an，它们的最大公约数为 d。那么可以表示成 ai &#x3D; di * bi，其中bi为除数。\同时，sum &#x3D; a1 + a2 + … + an &#x3D; d * (b1 + b2 + … + bn)。\<br>根据这个性质，数组元素的和sum一定是最大公约数 d 的倍数。\因此，如果我们能够通过对数组元素求和得到 sum，就可以通过对 sum 求最大公约数，从而得到所有元素的最大公约数。\\<br>2.<br>$$</p>
<span id="more"></span>

<h3 id="积性函数"><a href="#积性函数" class="headerlink" title="积性函数"></a>积性函数</h3><ul>
<li><p>积性函数都可以用欧拉筛求解</p>
</li>
<li><p>积性函数性质：<br>$$<br>定义在所有正整数上的函数称为算术函数(或者数论函数)\<br>如果算术函数f对任意两个互素的正整数p和q，均有f(pq)&#x3D;f(p)f(q)，称为积性函数（乘性函数）\<br>如果对任意两个正整数p和q均有f(pq)&#x3D;f(p)f(q)，则为完全积性函数\<br>积性函数的和函数，也是积性函数。若f是积性函数，则F(n) &#x3D; Σ_{d|n}f(d)也为积性函数。d|n表示d是n的因子。\<br>常见问题：\<br>(1)算f的第n项f(n)；\<br>(2)算f在1到n的所有项：f(1),f(2),…,f(n)\<br>(3)算f前n项的和Σ_{i&#x3D;1}^{n}f(i)，即前缀和<br>$$</p>
</li>
</ul>
<h3 id="质因数"><a href="#质因数" class="headerlink" title="质因数"></a>质因数</h3><ul>
<li><p>试除法判定质数（朴素法）：</p>
<ul>
<li>$时间复杂度O(\sqrt{n})$</li>
<li>优化原理（见代码注释处）：对于一个数x，若是合数，则必可以拆分为2<strong>个约数（一大一小）</strong>，若在<code>i &lt;= sqrt(x) &lt;--&gt;  i*i &lt;= x</code>范围内，找不到<strong>小约数</strong>，则表示该数x是质数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//0，1等不需判断</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x/i; i++) <span class="comment">//不推荐：sqrt()，因为每次都要算，该函数比较慢；i*i则有溢出风险</span></span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>试除法分解质因数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++)</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) x/= i, s++;</span><br><span class="line">            cout&lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) cout&lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; <span class="number">1</span> &lt;&lt; endl; <span class="comment">//n中最多只包含一个大于根号n的数字，eg：若有两个，则乘回去必大于n</span></span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>朴素筛法求素数</p>
<ul>
<li>$时间复杂度：O(NloglogN)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">//primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">//st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//埃氏筛优化： i &lt;= sqrt(n); //约数定理。约数成对出现，一定有一个小*一个大</span></span><br><span class="line"><span class="comment">//for(int j = i*i;),因前面的已被更小的质数分解。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>线性筛求素数（欧拉筛）</p>
<ul>
<li>$时间复杂度O(N)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> prime[N]; <span class="comment">//保存素数，节约空间的话可缩小大小</span></span><br><span class="line"><span class="type">bool</span> vis[N]; <span class="comment">//记录是否被筛</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_sieve</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">//欧拉筛，返回素数的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 记录素数个数</span></span><br><span class="line">   <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)); <span class="comment">// 初始化</span></span><br><span class="line">   <span class="built_in">memset</span>(prime,<span class="number">0</span>,<span class="built_in">sizeof</span>(prime)); <span class="comment">// 初始化</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="comment">// 检查每个数，删除其中的合数</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[i]) prime[cnt++] = i; <span class="comment">// 如果没有筛过，是素数，记录；第一个素数为2</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)  <span class="comment">//用已经得到的素数去筛出后面的数</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span>(i * prime[j] &gt; n) <span class="keyword">break</span>; <span class="comment">//只筛选小于或等于n的数字</span></span><br><span class="line">         vis[i * prime[j]] = <span class="number">1</span>; <span class="comment">//关键1：用x的最小质因数筛去x</span></span><br><span class="line">         <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//关键2：如果不是这个数的最小质因数，则结束。</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个合数一定有一个最小质数，让其被其最小质数筛出，以达到不被重复筛去的步骤冗余。</span></span><br><span class="line"><span class="comment">//具体操作：（1）逐一检查2-n之间的所有数，第一个检查的是2，是第一个素数；（2）当检查到第i个数时，利用已经求得的素数去筛掉对应的合数x，而且是用x的最小质因数去筛</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//if(i % prime[j] == 0) break;表示，每次循环只筛去该质数的下一个最近循环（即大于i，的最近一个）合数。因为：：：i是该素数的合数，则退出，因为，下一个素数*i 一定是本素数的合数，不满足：最小被素数除</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="求约数"><a href="#求约数" class="headerlink" title="求约数"></a>求约数</h3><ul>
<li><p>试除法求所有约数</p>
<ul>
<li>$时间复杂度O(nlogn)$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i*i &lt;= x; i++)</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i != x/i) res.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>约数个数 和 约数之和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">如果 N = p1^c1 * p2^c2 * ... *pk^ck</span><br><span class="line">约数个数： (c1 + <span class="number">1</span>) * (c2 + <span class="number">1</span>) * ... * (ck + <span class="number">1</span>)</span><br><span class="line">约数之和： (p1^<span class="number">0</span> + p1^<span class="number">1</span> + ... + p1^c1) * ... * (pk^<span class="number">0</span> + pk^<span class="number">1</span> + ... + pk^ck)</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//法一：试除法。优化：约数成对出现，只需i*i&lt;=n即可</span></span><br><span class="line"><span class="comment">//欧拉筛求最小质因数+素数</span></span><br><span class="line"><span class="comment">//eg:求正整数的约数个数</span></span><br><span class="line"> <span class="comment">//法1：质因数分解</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="type">int</span> n;</span><br><span class="line">   <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(n % i == <span class="number">0</span>) <span class="comment">// 缩小n，加快速度，毕竟如 360 = 2^3 * 3^2 * 5^1, 当除了3次2，则剩下的数就缩小了。注：肯定都是质数，因为如4，已经被2除过了，所以%4 != 0, 即合数都不可能出现，已被拆分为质数了</span></span><br><span class="line">     &#123;</span><br><span class="line">       tmp++;</span><br><span class="line">       n /= i;<span class="comment">//缩小</span></span><br><span class="line">     &#125;</span><br><span class="line">     ans *= (tmp + <span class="number">1</span>);<span class="comment">//+1是因为0次幂</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(n != <span class="number">1</span>)</span><br><span class="line">     ans *= (<span class="number">1</span>+<span class="number">1</span>); <span class="comment">//最后一个质数，比如上面的5，单独的</span></span><br><span class="line">   cout &lt;&lt; ans;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求约数之和：等比数列求和: a1[p1^(k+1) - 1]/(p1 - 1) * ....(p != 1; 其中的a1就是p1^0，首项，为1)</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>( <span class="type">int</span>  i = <span class="number">2</span>; i*i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">       <span class="type">int</span> tmp = i;</span><br><span class="line">       <span class="keyword">while</span>( n % i == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           tmp *= i;</span><br><span class="line">           n /= i;</span><br><span class="line">       &#125;</span><br><span class="line">       ans *= (tmp - <span class="number">1</span>) / (i - <span class="number">1</span>);<span class="comment">//a1=1</span></span><br><span class="line">      <span class="comment">//或者：t = 1, t = pt+1,-&gt; t = p(pt+1)+1 = p^2t+p+1...-&gt;p^a+p^a-1...+1(p^0)</span></span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">if</span>(n != <span class="number">1</span>)</span><br><span class="line">       ans *= (n + <span class="number">1</span>); <span class="comment">// 因为（n^2 -1）/(n-1)</span></span><br><span class="line">   cout&lt;&lt;ans;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>




</li>
<li><p>欧几里得算法(辗转相除法<code>gcd</code>)–求最大公约数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// d|a, d|b --&gt; d|(a+b) --&gt; d|(ax+by)--(被除数在左边)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>求欧拉函数</p>
<ul>
<li><p>$φ(n) &#x3D; 1到n-1之间的与n互素（即无公因数，除了1）的数的个数，即φ(6) &#x3D; 2 ，即(1,2,3,4,5中，1，5于6互素)$</p>
</li>
<li><p>$求φ(N)的欧拉函数时，先对N分解质因数（即素数）&#x3D;p_1^{α_1}p_2^{α_2}….p_k^{α_k}（与幂数无关）,\则φ(N)&#x3D;N(1-\frac{1}{p_1})(1-\frac{1}{p_2})…(1-\frac{1}{p_k})（容斥原理）$</p>
<ul>
<li>例子：$φ(6)&#x3D;2<em>3（2和3都是素数），φ(6)&#x3D;6</em>(1-\frac{1}{2})(1-\frac{1}{3})&#x3D;2$</li>
</ul>
</li>
<li><p>欧拉函数用容斥原理证明：$先对p_1^{α_1}p_2^{α_2}….p_k^{α_k}中的质数p_1…p_k，去掉它们在1到n中的所有倍数，在把去掉多次的数加回来\（eg:p_1p_2的倍数被减去2次），再删去p_1p_2p_3的倍数…$</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++)</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>筛法求欧拉函数</p>
<ul>
<li>一个<strong>质数p</strong>的欧拉函数显然有p-1个，因为从1~p-1都与p互质。</li>
<li>$n&#x3D; p^k,p是素数，即，p是质数，则与p不互质的数一定为p的倍数，那么，在P^k范围内，共有p^{k-1}个倍数。所以:-p^{k-1}$</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//统计欧拉函数之和当数据范围n为10的6次方，就要开long long存储数据了。不然会溢出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            prime[cnt ++] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>; <span class="comment">//一个质数p的欧拉函数显然有p-1个，因为从1~p-1都与p互质。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n/ i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="comment">//说明prime[j]是i的最小质因子</span></span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j]; <span class="comment">//i与prime[j]不互质，因为i是prime[j]的幂次结果，即：2^2+2^1 = 6，与2不互质，6是2的幂次的结果。不同幂次之间不互质。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>); <span class="comment">//i与primes[j]互素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>快速幂</p>
<ul>
<li><p>$时间复杂度：O(logk)$</p>
</li>
<li><p>求$ m^k\ mod\ p$，例子：$4^5\ mod\ 10,先快速幂计算4^{2^0},4^{2^1},4^{2^2}(够了)mod\ 10的结果保存，\然后4^5将幂5–&gt;(5)_2&#x3D;101,得知，4^5&#x3D;4^{2^0}+4^{2^2},\则4^5\ mod\ 10 &#x3D; 4^{2^0}\ (mod\ 10)+4^{2^2}\ (mod\ 10),又该些结果已提前预处理，则速度很快。$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求 m^k mod p，时间复杂度 O(logk)。</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">1</span> % p;<span class="comment">//若有数据：k=0,p=1这种情况下,res = 1是会出错的，改为：res = 1 % p</span></span><br><span class="line">    <span class="type">int</span> t = m; <span class="comment">//long long</span></span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res = res * t % p;</span><br><span class="line">        t = t * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">//res等建议开long long，数论容易爆数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速幂求逆元（此处为取模的乘法逆元，不是普通的乘法逆元）</p>
<ul>
<li>$b与m互质,对任意整数a，有b与m互质,对任意整数a，有:b|a≡x*a(mod\ m),x&#x3D;b^{-1}（表示逆元）,bb^{-1}≡1(mod\ m)$</li>
<li><strong>由费马小定理</strong>:$b^{p-1}≡1(mod\ p),p为素数$，则易知，求b的逆元可以变为：$b^{p-1}&#x3D;bb^{p-2}≡1(mod\ p),p为素数$，即$b^{p-2}$为所求逆元，由快速幂可以得到$b^{p-2}$</li>
</ul>
</li>
<li><p><strong>费马小定理</strong>:$b^{p-1}≡1(mod\ p),p为素数$（欧拉定理：gcd(a,m) &#x3D; 1，则有$a^{φ(m)}≡1(mod\ m)$)</p>
</li>
</ul>
</li>
<li><p>扩展欧几里得算法（扩展辗转相除法）</p>
<ul>
<li><p>裴蜀定理：关于<code>GCD</code>（最大公约数）得一个算法。若a与b均为整数，则有整数x和y使得$ax+by&#x3D;gcd(a,b)$，推论：$a与b互素当仅存在整数x和y，使得ax+by&#x3D;1$</p>
</li>
<li><p>扩展欧几里得算法即，求对于任意整数a和b，求x和y可得到它们的最大公约数。</p>
</li>
<li><p>$时间复杂度：$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b ) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求解线性同余方程ax≡b(mod m)。</p>
</li>
</ul>
</li>
<li><p>中国剩余定理：</p>
<ul>
<li>给定k个两两互质的数$m_1,m_2,m_3…m_k$，求解线性同余方程<strong>组</strong><br>$$<br>x≡a_1\ mod\ m_1\<br>x≡a_2\ mod\ m_2\<br>…\<br>x≡a_k\ mod\ m_k\<br>令M &#x3D;m_1m_2…m_k,\ \ \ \ \ M_i &#x3D;\frac{M}{m_i}\<br>则M_i与m_i互质，则求M_i\ mod\ m_i的逆元M^{-1}_i,由：扩展欧几里得可算。\<br>即ax &#x3D; 1(mod\ m)求逆\<br>又x &#x3D; a_1<em>M_1</em>M^{-1}_1 + a_2<em>M_2</em>M^{-1}_2 + a_k<em>M_k</em>M^{-1}_k，中，\全部都对m_1求mod，则除了a_1<em>M_1</em>M^{-1}_1结果为a_1，其余的M_2,M_3…都包含m_1，\则取模后都为0，则结果为：x≡a_1(mod\ m_1)，其余的类似。\<br>$$</li>
</ul>
</li>
<li><p>高斯消元</p>
<ul>
<li><p>$时间复杂度：$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a[N][N]是增广矩阵</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )   <span class="comment">// 找到绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;<span class="comment">//eps精度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);      <span class="comment">// 将绝对值最大的行换到最顶端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="comment">// 将当前行的首位变成1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )       <span class="comment">// 用当前行将下面所有的列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )</span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>递推法求组合数</p>
<ul>
<li><p>即：$C^b_a &#x3D; C^b_{a-1}+C^{b-1}_{a-1}，选a和不选a$</p>
</li>
<li><p>$时间复杂度：$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c[a][b] 表示从a个苹果中选b个的方案数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">        <span class="keyword">if</span>(!j) c[i][j] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> c[i][j] = (c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>]) % mod</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通过预处理逆元的方式求组合数</p>
<ul>
<li><p>$时间复杂度：$</p>
</li>
<li><p>首先预处理出所有阶乘取模的余数<code>fact[N]</code>，以及所有阶乘取模的逆元<code>infact[N]</code>。如果取模的数是质数，可以用费马小定理求逆元</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span>    <span class="comment">// 快速幂模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理阶乘的余数和阶乘逆元的余数</span></span><br><span class="line"><span class="comment">//即：N!, 和1/N!</span></span><br><span class="line">fact[<span class="number">0</span>] = infact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++ )<span class="comment">//求阶乘</span></span><br><span class="line">&#123;</span><br><span class="line">    fact[i] = (LL)fact[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    infact[i] = (LL)infact[i - <span class="number">1</span>] * <span class="built_in">qmi</span>(i, mod - <span class="number">2</span>, mod) % mod; <span class="comment">//费马小定理+快速幂求逆元</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Lucas(卢卡斯)定理</p>
<ul>
<li><p>$时间复杂度：$</p>
</li>
<li><p>$$<br>若p是质数，则对于任意整数 1 &lt;&#x3D; m &lt;&#x3D; n，有：\<br>C(n, m) &#x3D; C(n \mod p，m \mod p) * C( \frac{c}{p}, \frac{m}{p}) \mod p<br>\\<br>证明：先将a和b展开：\<br>a &#x3D; a_0<em>p^0+a_1</em>p^1+…+a_k<em>p^k\<br>b &#x3D; b_0</em>p^0+b_1<em>p^1+…+b_k</em>p^k\<br>   由二项式定理：(1+x)^p &#x3D; C_p^01^px^0 + C_p^11^{p-1}x^1 + …C_p^p1^0x^p\<br>   又p为质数，那么，展开式中间的所有项，都是p<em>k，那么p</em>k\ mod\ p &#x3D;&#x3D;0,则只有第一项和最后一项保留\<br>   即：(1+x)^p &#x3D; 1+x^p(mod\ p)…(未写完，手酸)<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span>  <span class="comment">// 快速幂模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span>  <span class="comment">// 通过定理求组合数C(a, b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    LL x = <span class="number">1</span>, y = <span class="number">1</span>;  <span class="comment">// x是分子，y是分母</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a, j = <span class="number">1</span>; j &lt;= b; i --, j ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        x = (LL)x * i % p;</span><br><span class="line">        y = (LL) y * j % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x * (LL)<span class="built_in">qmi</span>(y, p - <span class="number">2</span>, p) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);<span class="comment">//Ca b，因为a和b都小于p</span></span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>分解质因数法求组合数</p>
<ul>
<li><p>$时间复杂度：$</p>
</li>
<li><p>$$<br>当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：\<br>1. 筛法求出范围内的所有质数\<br>2. 通过 C(a, b) &#x3D; \frac{a!}{b!(a - b)!} 这个公式求出每个质因子的次数。\<br>n!中p的次数是 \frac{n}{p} + \frac{n}{p^2} + \frac{n}{p^3} + …\（即：除以p^k则只会剩下p^k被加了多少次。n&#x3D;a_0p^0+a_1p^1+…\<br>3. 用高精度乘法将所有质因子相乘<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// 存储所有质数</span></span><br><span class="line"><span class="type">int</span> sum[N];     <span class="comment">// 存储每个质数的次数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个数是否已被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span>      <span class="comment">// 线性筛法求素数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p)</span>       <span class="comment">// 求n！中p的次数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        res += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> b)</span>       <span class="comment">// 高精度乘低精度模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">get_primes(a);</span>  <span class="comment">// 预处理范围内的所有质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 求每个质因数的次数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> p = primes[i];</span><br><span class="line">    sum[i] = <span class="built_in">get</span>(a, p) - <span class="built_in">get</span>(b, p) - <span class="built_in">get</span>(a - b, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i ++ )     <span class="comment">// 用高精度乘法将所有质因子相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sum[i]; j ++ )</span><br><span class="line">        res = <span class="built_in">mul</span>(res, primes[i]);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>卡特兰数：</p>
<ul>
<li>$$<br>给定n个0和n个1，他们按照某种顺序排成长度为2n的序列，\满足任意前缀中0的个数都不少于1的个数的序列的数量为：\Cat(n) &#x3D; \frac{C_{2n}^n}{n+1}<br>$$</li>
</ul>
</li>
<li><p>容斥原理:</p>
<ul>
<li><p>$由C_n^0+C_n^1+C_n^2+…+C_n^n &#x3D; 2^n知，C_n^1+C_n^2+…+C_n^n &#x3D; 2^n-1，即以上的时间复杂度为O(2^m)，即m个集合$</p>
</li>
<li><p>$1&lt;&#x3D;k&lt;&#x3D;n,C_k^1-C_k^2+…+(-1)^{k-1}C_k^k &#x3D; 1&#x3D;C_n^0(举(1-1)^n展开例子)$</p>
</li>
<li><p>同时是k个数的倍数，则在1~n范围内，有这么多个倍数：$\frac{n}{p_1p_2p_3…p_k}下取整$</p>
</li>
<li><p><strong>位运算枚举</strong>(常见好用，相当于dfs爆搜)所有答案（即选与不选），符号的证负，取决于选的多少（奇正偶负）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1&lt;&lt;m即2^m个选择，此处共2^m-1个选择，因为全不选排除。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1</span> &lt;&lt; m;i++) <span class="comment">//包含了如：00000 5位2进制数中，所有答案如00001，000101，000111...</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) <span class="comment">//m是把i进行2进制移位操作</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span> != <span class="number">0</span>) <span class="comment">//判断移位值0 or 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>NIM</code>游戏</p>
<ul>
<li><p>给定N堆物品，第<code>i</code>堆物品有<code>Ai</code>个。两名玩家轮流行动，每次可以任选一堆，取走<strong>任意多</strong>个物品，可把一堆取光，但<strong>不能不取</strong>。取走<strong>最后一件物品者获胜</strong>。两人都采取最优策略，问<strong>先手是否必胜</strong>。</p>
</li>
<li><p>我们把这种游戏称为<code>NIM</code>博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。</p>
</li>
<li><p>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都<strong>只考虑理想情况</strong>，即两人<strong>均无失误</strong>，都采取最优策略行动时游戏的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">举个例子：有<span class="number">2</span>堆不同石子的堆，分别为<span class="number">3</span>和<span class="number">5</span>；先手将多的<span class="number">5</span>--&gt;<span class="number">3</span>，此时石堆变成<span class="number">3</span>，<span class="number">3</span>相同数量。此时后手必须拿石子，只要先手保持和后手一样的动作（拿一样的石子），就能确保在   偶数次（总次数必为偶数）   拿完，也确保下一次后手必定没有石子拿。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>NIM</code>博弈<strong>不存在平局</strong>，只有先手必胜和先手必败两种情况。</p>
</li>
<li><p><code>定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0</code><em>（A为最上面的第i堆物品有Ai个）</em></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/358979118">组合博弈中最经典的尼姆（Nim）游戏，怎么玩才能必胜？ - 知乎 (zhihu.com)</a></p>
</li>
</ul>
</li>
<li><p>公平组合游戏<code>ICG</code></p>
<ul>
<li>$$<br>若一个游戏满足：\<br>1.由两名玩家交替行动；\<br>2.在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；\<br>3.不能行动的玩家判负；\<br>则称该游戏为一个公平组合游戏。\<br>NIM博弈属于公平组合游戏，但常见的棋类游戏，比如围棋，就不是公平组合游戏。\因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。<br>$$</li>
</ul>
</li>
<li><p>有向图游戏</p>
<ul>
<li>$$<br>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。\两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。\该游戏被称为有向图游戏。<br>任何一个公平组合游戏都可以转化为有向图游戏。\具体方法是：\把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。<br>$$</li>
</ul>
</li>
<li><p><code>Mex</code>运算</p>
<ul>
<li>$$<br>设S表示一个非负整数集合。\定义mex(S)为求出不属于集合S的最小非负整数的运算，\即：<br>mex(S) &#x3D; min{x}, x属于自然数，且x不属于S，\<br>比如：S&#x3D;{1,2,3},则mex(S) &#x3D; 0,0属于自然数，且不在S中最小<br>$$</li>
</ul>
</li>
<li><p><code>SG</code>函数<strong>（通法）</strong></p>
<ul>
<li>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点<code>y1, y2, …, yk</code>，定义<code>SG(x)</code>为x的后<strong>继节点</strong><code>y1, y2, …, yk </code>的SG函数值构成的集合再执行<code>mex(S)</code>运算的结果，即：<br><code>SG(x) = mex(&#123;SG(y1), SG(y2), …, SG(yk)&#125;)</code>，即不能到达的最小状态<br>特别地，整个有向图游戏G的SG函数值<strong>被定义为</strong>有向图游戏<strong>起点s</strong>的SG函数值，即<code>SG(G) = SG(s)。</code><br>终止状态的<code>SG(x)</code>状态被定为0，即其余的，看其能到那些位置的状态，则其不能到的最小值为其定义状态。[SG(x)!&#x3D;0必胜状态，即任何一种非零状态，一定可以由一种方式（路径如图）走到0]</li>
</ul>
</li>
<li><p>有向图游戏的和</p>
<ul>
<li>设<code>G1, G2, …, Gm </code>是m个<strong>有向图游戏</strong>。定义有向图游戏G，它的行动规则是<strong>任选某个</strong>有向图游戏<code>Gi</code>，并在<code>Gi</code>上行动<strong>一步</strong>。G被称为有向图游戏<code>G1, G2, …, Gm</code>的<strong>和</strong>。<br>有向图游戏的<strong>和的SG函数值</strong>等于它包含的<strong>各个子游戏</strong>SG函数值的<strong>异或和</strong>，即：<br><code>SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</code></li>
</ul>
</li>
<li><p>定理：</p>
<p>$$<br>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。<br>\<br>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。<br>$$</p>
</li>
<li><p>NIM游戏拓展<br>$$<br>K-NIM游戏：\<br>可以同时取最多k堆石头\<br>结论：if:将所有的a_i转为二进制，若每个二进制位上的1的个数即Σ1\ mod\ (k+1) &#x3D;&#x3D; 0 则为必败局面\\</p>
<p>multi-nim游戏(如AcWing的集合拆分)：\<br>每次选一堆石头，将其分裂为几堆更小的堆\<br>结论：每堆石头的SG函数的值为其子SG的异或和，即SG(S) &#x3D; mex(SG(a_1\ xor\ a_2\ xor…),SG(b_1\ xor\ b_2\ xor…),…)<br>\\</p>
<p>anti-nim游戏：<br>最后一个获取石头的必败<br>结论：状态为必胜态，当仅:\sum为所有石头堆石头数量的异或和<br>①所有堆的石子个数为1，且sum&#x3D;&#x3D;0，②至少有一堆的石子个数大于1，且sum!&#x3D;0<br>\\</p>
<p>阶梯NIM游戏：<br>将第i堆（第i个阶梯上）的石子移到第i-1堆（第i-1个阶梯），当移动到地面就不可在移动\<br>结论：当奇数堆的石子数的异或和为0时(if(i\ mod\ 2)sum\ \ xor&#x3D; a[i])，为必败态，不为0则必胜态（证明容易，若为0，则下一步必不为0）。win &#x3D; sum!&#x3D;0?true:false;<br>$$</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法板子</category>
      </categories>
  </entry>
  <entry>
    <title>贪心</title>
    <url>/2024/03/19/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<ul>
<li><p>新颖：推出公式+数列等不等式</p>
</li>
<li><p>国王游戏。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法板子</category>
      </categories>
  </entry>
  <entry>
    <title>树状类算法</title>
    <url>/2024/03/19/%E6%A0%91%E7%8A%B6%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><ul>
<li><p><a href="https://blog.csdn.net/the_zed/article/details/105126583">https://blog.csdn.net/the_zed/article/details/105126583</a></p>
</li>
<li><p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等.</p>
</li>
<li><p>并查集主要由一个整型数组<code>pre[ ]</code>和两个函数<code>find( )</code>、<code>join( )</code>构成。数组 <code>pre[]</code> 记录了每个点的前驱节点是谁，函数 <code>find(x)</code> 用于查找指定节点 x 属于哪个集合，函数 <code>join(x,y)</code> 用于合并两个节点 x 和 y 。</p>
</li>
<li><p>其join()和find()函数实现：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>					<span class="comment">//查找x的教主</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(pre[x] != x)			<span class="comment">//如果x的上级不是自己（则说明找到的人不是教主）</span></span><br><span class="line">		x = pre[x];				<span class="comment">//x继续找他的上级，直到找到教主为止</span></span><br><span class="line">	<span class="keyword">return</span> x;					<span class="comment">//教主驾到~~~</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>                     <span class="comment">//我想让虚竹和周芷若做朋友</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x), fy=<span class="built_in">find</span>(y);            <span class="comment">//虚竹的老大是玄慈，芷若MM的老大是灭绝</span></span><br><span class="line">    <span class="keyword">if</span>(fx != fy)                           <span class="comment">//玄慈和灭绝显然不是同一个人</span></span><br><span class="line">        pre[fx]=fy;                        <span class="comment">//方丈只好委委屈屈地当了师太的手下啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ul>
<li>路径压缩一（优化find）</li>
<li>即令所有间接上级直接挂钩于根节点（避免路径太长）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     				<span class="comment">//查找结点 x的根结点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[x] == x) <span class="keyword">return</span> x;		<span class="comment">//递归出口：x的上级为 x本身，即 x为根结点        </span></span><br><span class="line">    <span class="keyword">return</span> pre[x] = <span class="built_in">find</span>(pre[x]);	<span class="comment">//此代码相当于先找到根结点 rootx，然后pre[x]=rootx </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>该算法存在一个缺陷：只有当查找了某个节点的代表元（教主）后，才能对该查找路径上的各节点进行路径压缩。换言之，第一次执行查找操作的时候是实现没有压缩效果的，只有在之后才有效</p>
</li>
<li><p>路径压缩二（加权标记法）</p>
</li>
<li><p>加权标记法需要将树中所有节点都增设一个权值，用以表示该节点所在树中的高度（比如用<code>rank[x]=3</code>表示 x 节点所在树的高度为3）。这样一来，在合并操作的时候就能通过这个权值的大小来决定谁当谁的上级</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x=<span class="built_in">find</span>(x);							<span class="comment">//寻找 x的代表元</span></span><br><span class="line">    y=<span class="built_in">find</span>(y);							<span class="comment">//寻找 y的代表元</span></span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> ;					<span class="comment">//如果 x和 y的代表元一致，说明他们共属同一集合，则不需要合并，直接返回；否则，执行下面的逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(rank[x]&gt;rank[y]) pre[y]=x;		<span class="comment">//如果 x的高度大于 y，则令 y的上级为 x</span></span><br><span class="line">    <span class="keyword">else</span>								<span class="comment">//否则</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rank[x]==rank[y]) rank[y]++;	<span class="comment">//如果 x的高度和 y的高度相同，则令 y的高度加1</span></span><br><span class="line">        pre[x]=y;						<span class="comment">//让 x的上级为 y</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>附图如下：</p>
</li>
<li><img src="/.com//03/19/%E6%A0%91%E7%8A%B6%E7%B1%BB%E7%AE%97%E6%B3%95/8ff3397f-86e8-44b5-b493-9ebc744feb7b.png" class title="image"></li>
<li><img src="/.com//03/19/树状类算法/shulen.png" alt="image"></li>
<li></li>
<li><p>1、如果<code>rank[x] &lt; rank[y]</code>，则令<code>pre[x] = y</code>；2、如果<code>rank[x] == rank[y]</code>，则可任意指定上级；3、如果<code>rank[x] &gt; rank[y]</code>，则令<code>pre[y] = x</code>；</p>
</li>
<li><p>所有操作总结</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>  N=<span class="number">1005</span>					<span class="comment">//指定并查集所能包含元素的个数（由题意决定）</span></span><br><span class="line"><span class="type">int</span> pre[N];     					<span class="comment">//存储每个结点的前驱结点 </span></span><br><span class="line"><span class="type">int</span> rank[N];    					<span class="comment">//树的高度 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span>     				<span class="comment">//初始化函数，对录入的 n个结点进行初始化 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//下标从某处开始。看题目给定的起始下标是多少。</span></span><br><span class="line">        pre[i] = i;     			<span class="comment">//每个结点的上级都是自己 </span></span><br><span class="line">        rank[i] = <span class="number">1</span>;    			<span class="comment">//每个结点构成的树的高度为 1 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     	 		    <span class="comment">//查找结点 x的根结点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[x] == x) <span class="keyword">return</span> x;  		<span class="comment">//递归出口：x的上级为 x本身，则 x为根结点 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(pre[x]); 			<span class="comment">//递归查找 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     				<span class="comment">//改进查找算法：完成路径压缩，将 x的上级直接变为根结点，那么树的高度就会大大降低 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[x] == x) <span class="keyword">return</span> x;		<span class="comment">//递归出口：x的上级为 x本身，即 x为根结点 </span></span><br><span class="line">    <span class="keyword">return</span> pre[x] = <span class="built_in">find</span>(pre[x]);   <span class="comment">//此代码相当于先找到根结点 rootx，然后 pre[x]=rootx </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>      		<span class="comment">//判断两个结点是否连通 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y);  	<span class="comment">//判断两个结点的根结点（即代表元）是否相同 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x);						<span class="comment">//寻找 x的代表元</span></span><br><span class="line">    y = <span class="built_in">find</span>(y);						<span class="comment">//寻找 y的代表元</span></span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> <span class="literal">false</span>;			<span class="comment">//如果 x和 y的代表元一致，说明他们共属同一集合，则不需要合并，返回 false，表示合并失败；否则，执行下面的逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(rank[x] &gt; rank[y]) pre[y]=x;		<span class="comment">//如果 x的高度大于 y，则令 y的上级为 x</span></span><br><span class="line">    <span class="keyword">else</span>								<span class="comment">//否则</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(rank[x]==rank[y]) rank[y]++;	<span class="comment">//如果 x的高度和 y的高度相同，则令 y的高度加1</span></span><br><span class="line">        pre[x]=y;						<span class="comment">//让 x的上级为 y</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;						<span class="comment">//返回 true，表示合并成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><ul>
<li><a href="https://www.bilibili.com/video/BV1ce411u7qP/?spm_id_from=333.337.search-card.all.click&vd_source=9b8c617d6963309a6ee72210dfcda8fa">https://www.bilibili.com/video/BV1ce411u7qP/?spm_id_from=333.337.search-card.all.click&amp;vd_source=9b8c617d6963309a6ee72210dfcda8fa</a></li>
<li>用数组来模拟树形结构</li>
<li>树状数组用于解决：区间更新，单点查询。</li>
<li>知识点：<code>lowbit(x)</code>运算：计算一个非负整数n在二进制下的最低为1及后面的0构成的数，即<code>lowbit(x) = x&amp;(-x);</code></li>
<li>-x表示x取反+1：如12（1100）取反+1：（0011+1 –》 0100）则<code>12&amp;-12 = 4</code>,所以<code>lowbit(12) = 4</code>,即<code>b[12]</code>的上级包含数组为<code>b[16] = b[12+lowbit[12]]</code></li>
</ul>
<p><img src="/.com//2cc690ee-b4ad-4ca8-b8eb-9c2e0c0d9ef9.png" alt="image"></p>
<img src="/.com//03/19/%E6%A0%91%E7%8A%B6%E7%B1%BB%E7%AE%97%E6%B3%95/6bd5eb60-06f6-4365-81d3-e2eee48ec17d.png" class title="image">
<img src="/.com//03/19/%E6%A0%91%E7%8A%B6%E7%B1%BB%E7%AE%97%E6%B3%95/a26d8558-ff73-44be-a017-ddce34896b93.png" class title="image">
<img src="/.com//03/19/%E6%A0%91%E7%8A%B6%E7%B1%BB%E7%AE%97%E6%B3%95/b0d20519-840d-42b5-b694-73f48e2e3809.png" class title="image">


<ul>
<li>码蹄集：快排变形(求逆序对&#x2F;顺序对)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N], n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">        c[i] += x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &gt; <span class="number">0</span>; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">        ans += c[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b[x] == b[y])   </span><br><span class="line">        <span class="keyword">return</span> x &gt; y;</span><br><span class="line">    <span class="keyword">return</span> b[x] &gt; b[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(a[i], <span class="number">1</span>);</span><br><span class="line">        ans += <span class="built_in">sum</span>(a[i] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/weixin_59670163/article/details/125190268">https://blog.csdn.net/weixin_59670163/article/details/125190268</a></p>
<ul>
<li><p>求逆序对</p>
</li>
<li><p><a href="https://blog.csdn.net/qq_41431457/article/details/88945833">https://blog.csdn.net/qq_41431457/article/details/88945833</a></p>
</li>
<li><p>离散化：通过将数组中不同大小的位置进行大小离散化，如<code>1，5，3，8，999</code>—&gt;另开一个数组<code>d[5]来存储， d[i]用来存放第i大的数在原序列的什么位置，比如原序列a=&#123;5，3，4，2，1&#125;，第一大就是5，他在a中的位是1，所以d[1]=1，同理d[2]=3，········所以d数组为&#123;1，3，2，4，5&#125;</code></p>
</li>
<li><p>转换之后，空间复杂度就没这么高了，但不是求d中的逆序对了，而是求d中的正序对，来看一下怎么求的：</p>
</li>
</ul>
<p>首先把1放到树状数组t中，此时t只有一个数1，t中比1小的数没有，sum+&#x3D;0<br>再把3放到树状数组t中，此时t只有两个数1，3，比3小的数只有一个，sum+&#x3D;1<br>把2放到树状数组t中，此时t只有两个数1，2，3，比2小的数只有一个，sum+&#x3D;1<br>把4放到树状数组t中，此时t只有两个数1，2，3，4，比4小的数有三个，sum+&#x3D;3<br>把5放到树状数组t中，此时t只有两个数1，2，3，4，5，比5小的数有四个，sum+&#x3D;4<br>最后算出来，总共有9个逆序对，可以手算一下原序列a，也是9个逆序对，</p>
<p>具体实现：</p>
<p>另d[1]&#x3D;1, d[2]&#x3D;2········a[n]&#x3D;n<br>根据原数组a中的元素的大小进行排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[M],d[M],t[M],n;</span><br><span class="line"><span class="comment">//原数组/ 离散化后的数组/ 树状数组 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a[x]==a[y]) <span class="keyword">return</span> x&gt;y;<span class="comment">//避免元素相同 </span></span><br><span class="line">	<span class="keyword">return</span> a[x]&gt;a[y];<span class="comment">//按照原序列第几大排列 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	cin&gt;&gt;a[i],d[i]=i;<span class="comment">//初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="comment">//排序时候d就是离散化的数组了 </span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<hr>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><ul>
<li><p>分治法思想+二叉树结构+lazy-Tag技术</p>
</li>
<li><p>分治法自定向下建立，每次分治，折半。大区间的解可以由小区间的解合并而来。</p>
</li>
<li><p>除了最后一层，其余层数都是满的。</p>
</li>
<li><p>若有区间内有n个结点，则需要4*n的空间。要开满二叉树。假设最后一层，只有1个结点，但要开2 *n个结点。倒数第二层满的，共n个，（往上n个和）</p>
</li>
<li><p>构造如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义根节点tree[1],即编号为1的结点是根。</span></span><br><span class="line"><span class="comment">//方法1，定义结构</span></span><br><span class="line"><span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> L,R,data; <span class="comment">//data存储区间和或最值等，看题目</span></span><br><span class="line">&#125;tree[<span class="number">4</span>*N];</span><br><span class="line"><span class="comment">//方法2，直接开数组，存储区间和或最值等。此处用第二种方法</span></span><br><span class="line">tree[<span class="number">4</span>*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>; &#125;  <span class="comment">//获取左孩子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125; <span class="comment">//获取右孩子，先左移再或1（加1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自底向上传递值，合并。此处为求区间和，可更改。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree[p] = tree[<span class="built_in">ls</span>(p)] + tree[<span class="built_in">rs</span>(p)];  <span class="comment">//求区间和。</span></span><br><span class="line">	<span class="comment">//求最小值则改为：tree[p] = min(tree[ls(p)], tree[rs(p)]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">built</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span> <span class="comment">//p为结点编号，pl，pr为数列的索引index区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//tag[p] = 0; //初始化lazy-tag，用于多次修改区间。</span></span><br><span class="line">    <span class="keyword">if</span> (pl == pr)<span class="comment">//最底层的叶子节点，存叶子结点的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[p] = a[pl];  <span class="comment">//叶子结点赋值。a为题给数列，如&#123;1,5,2,6,3&#125;</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (pl + pr) &gt;&gt; <span class="number">1</span>; <span class="comment">//折半递归</span></span><br><span class="line">    <span class="built_in">built</span>(<span class="built_in">ls</span>(p), pl, mid); <span class="comment">//lson递归</span></span><br><span class="line">    <span class="built_in">built</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);  <span class="comment">//rson递归</span></span><br><span class="line">    <span class="built_in">push_up</span>(p); <span class="comment">//自底向上传递值，合并。</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>区间查询</p>
<ul>
<li><p>查询区间最值<br>以数列{1, 4, 5, 8, 6, 2, 3, 9, 10, 7}为例子。圈内标号为最小值。x:[i,j]表示第几个编号（即谁家子树tree[x]，[i,j]表示管理的索引区间，如[2:3]，则对应数列的{4, 5}。如图</p>
</li>
<li><p>每次维护数组和查询区间最值复杂度都为O(logn)</p>
</li>
<li><p>查询区间和同理，如图。</p>
</li>
<li><img src="/.com//03/19/%E6%A0%91%E7%8A%B6%E7%B1%BB%E7%AE%97%E6%B3%95/18310f5e-3dfa-4450-86b7-5300341a6503.png" class title="image">
</li>
<li><p>分两种情况：</p>
<ul>
<li><p>①[L,R]完全覆盖[pl, pr].即L&lt;&#x3D;pl&lt;&#x3D;pr&lt;&#x3D;R.直接返回<code>tree[p]</code>即可</p>
</li>
<li><p>②[L,R]部分重叠[pl, pr].分别左右递归子树。获取该部分值。L &lt; pr,继续递归左子树，eg:查询[4,9]与第二个结点（见图）[1,5]有重叠，因为4&lt;5。同理R &gt; pl，继续递归右子树。<strong>（与mid重叠搜索。mid的左右都搜索，避免恰好卡边缘，不搜另一边，导致错失结果。比如[3,9]与[1,5]，左搜才行[1, 3]。右搜也检查一遍[4，5]）</strong></p>
</li>
<li><p>图解&amp;代码：</p>
<img src="/.com//03/19/%E6%A0%91%E7%8A%B6%E7%B1%BB%E7%AE%97%E6%B3%95/b8a7472d-47a9-4222-b133-db5caa008c71.jpeg" class title="160ee058726a976a901bb90b17700f7">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll L, ll R, ll p, ll pl, ll pr)</span>  <span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pl &gt;= L &amp;&amp; R &gt;= pr) <span class="keyword">return</span> tree[p]; <span class="comment">//完全覆盖(只可能恰好)，直接返回tree[p]，区间和</span></span><br><span class="line">    <span class="comment">// push_down(p, pl, pr); //不能覆盖，递归子树，先tag修改一下，若单纯的查询，此功能写上没啥坏处，只是将p的tag值下发给左右子树。</span></span><br><span class="line">    </span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    ll mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) res += <span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid);  <span class="comment">//左子结点重叠（eg:[4,7],[5,8]</span></span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid) res += <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);  <span class="comment">//递归右子树(eg:[7,9],[4,8])</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>lazy-tag标记（不写了，太多了，看书吧。就是记录该处已经修改过，但是不操作子树（不改子树）。在需要时（多次修改，且不同区间，但有重叠。），再将tag值传递给子树。让子树值也相加，并保存父亲传来的tag值。）</p>
</li>
<li><p>如图：</p>
<img src="/.com//03/19/%E6%A0%91%E7%8A%B6%E7%B1%BB%E7%AE%97%E6%B3%95/122329c5-81c0-44c8-813d-685b8bd8d342.jpeg" class title="2dcbec23614436193671a3353e052a3">
<img src="/.com//03/19/%E6%A0%91%E7%8A%B6%E7%B1%BB%E7%AE%97%E6%B3%95/86c1b905-4d0a-4a60-a574-b08252518bbf.jpeg" class title="dc6855997e831bb6d1fe768a1d7cf72">

<ul>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//给结点(索引)p打上标记。更新tree</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(ll p, ll pl, ll pr, ll d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tag[p] += d; <span class="comment">//标记赋值</span></span><br><span class="line">tree[p] += d * (pr - pl + <span class="number">1</span>);  <span class="comment">//多少个索引，多少个+d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于处理每次不同区间的，但有重复部分。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(ll p, ll pl, ll pr)</span></span></span><br><span class="line"><span class="function"><span class="comment">//p已有tag，向下调整tag给l，rson</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (tag[p]) <span class="comment">//表示有tag值，初始0表无</span></span><br><span class="line">&#123;</span><br><span class="line">   ll mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">   <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]);  <span class="comment">//把tag给左孩子，并修改左孩子值</span></span><br><span class="line">   <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);  <span class="comment">//把tag给左孩子，并修改左孩子值</span></span><br><span class="line">   tag[p] = <span class="number">0</span>; <span class="comment">//p自己的tag传递给son，自己归0</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间修改：[L, R]内每个元素+d</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(ll L, ll R, ll p, ll pl, ll pr, ll d)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= pl &amp;&amp; pr &lt;= R) <span class="comment">//覆盖，比如[4,9]覆盖[5,6]，[7,9]</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">addtag</span>(p, pl, pr, d); <span class="comment">//直接修改+d。不必在搜索son</span></span><br><span class="line">   <span class="keyword">return</span>;<span class="comment">//修改完毕，返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有完全覆盖，部分覆盖，把tag赋值给son。</span></span><br><span class="line"><span class="comment">//此处先于上边（即使多次之间返回，最终tag不断增加，</span></span><br><span class="line"><span class="comment">//还是会在某次不包含区间内分散给son）。（没覆盖就把传给son）</span></span><br><span class="line"><span class="built_in">push_down</span>(p, pl, pr); <span class="comment">//传tag给son</span></span><br><span class="line">ll mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (L &lt;= mid) <span class="built_in">updata</span>(L, R, <span class="built_in">ls</span>(p), pl, mid, d);  <span class="comment">//递归左子树</span></span><br><span class="line"><span class="keyword">if</span> (R &gt; mid) <span class="built_in">updata</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, d);  <span class="comment">//递归右子树</span></span><br><span class="line"><span class="built_in">push_up</span>(p);  <span class="comment">//更新</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>洛谷线段树模板题目:<a href="https://www.luogu.com.cn/problem/P3372">https://www.luogu.com.cn/problem/P3372</a></p>
</li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="comment">//define 简写 全称</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ll a[N];  <span class="comment">//记录数列</span></span><br><span class="line">ll tree[N &lt;&lt; <span class="number">2</span>]; <span class="comment">//完全满二叉树</span></span><br><span class="line">ll tag[N &lt;&lt; <span class="number">2</span>];  <span class="comment">//标记</span></span><br><span class="line"><span class="function">ll <span class="title">ls</span><span class="params">(ll p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>; &#125;  <span class="comment">//lchild search</span></span><br><span class="line"><span class="function">ll <span class="title">rs</span><span class="params">(ll p)</span> </span>&#123; <span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; <span class="comment">/*先移动再或1，即+1*/</span> &#125; <span class="comment">//rchild search</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(ll p)</span>  <span class="comment">//从下往上传递值（即father = son1+son2）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p] = tree[<span class="built_in">ls</span>(p)] + tree[<span class="built_in">rs</span>(p)];  <span class="comment">//求区间和。</span></span><br><span class="line">    <span class="comment">//求最小值则改为：tree[p] = min(tree[ls(p)], tree[rs(p)]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">built</span><span class="params">(ll p, ll pl, ll pr)</span> <span class="comment">//p为结点编号，pl，pr为索引index区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tag[p] = <span class="number">0</span>; <span class="comment">//初始化lazy-tag</span></span><br><span class="line">    <span class="keyword">if</span> (pl == pr)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[p] = a[pl];  <span class="comment">//叶子结点赋值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid = (pl + pr) &gt;&gt; <span class="number">1</span>; <span class="comment">//折半递归</span></span><br><span class="line">    <span class="built_in">built</span>(<span class="built_in">ls</span>(p), pl, mid); <span class="comment">//lson递归</span></span><br><span class="line">    <span class="built_in">built</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);  <span class="comment">//rson递归</span></span><br><span class="line">    <span class="built_in">push_up</span>(p); <span class="comment">//lson和rson赋值给father</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(ll p, ll pl, ll pr, ll d)</span> <span class="comment">//给结点(索引)p打上标记。更新tree</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tag[p] += d; <span class="comment">//标记赋值</span></span><br><span class="line">    tree[p] += d * (pr - pl + <span class="number">1</span>);  <span class="comment">//多少个索引，多少个+d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于处理每次不同区间的，但有重复部分。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(ll p, ll pl, ll pr)</span> <span class="comment">//p已有tag，向下调整tag给l，rson</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[p]) <span class="comment">//表示有tag值，初始0表无</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]);  <span class="comment">//把tag给左孩子，并修改左孩子值</span></span><br><span class="line">        <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);  <span class="comment">//把tag给左孩子，并修改左孩子值</span></span><br><span class="line">        tag[p] = <span class="number">0</span>; <span class="comment">//p自己的tag传递给son，自己归0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(ll L, ll R, ll p, ll pl, ll pr, ll d)</span>  <span class="comment">//区间修改：[L, R]内每个元素+d</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= pl &amp;&amp; pr &lt;= R) <span class="comment">//覆盖，比如[4,9]覆盖[5,6]，[7,9]</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">addtag</span>(p, pl, pr, d); <span class="comment">//直接修改+d。不必在搜索son</span></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//修改完毕，返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有完全覆盖，部分覆盖，把tag赋值给son。</span></span><br><span class="line">    <span class="comment">//此处先于上边（即使多次之间返回，最终tag不断增加，</span></span><br><span class="line">    <span class="comment">//还是会在某次不包含区间内分散给son）。（没覆盖就把传给son）</span></span><br><span class="line">    <span class="built_in">push_down</span>(p, pl, pr); <span class="comment">//传tag给son</span></span><br><span class="line">    ll mid = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">updata</span>(L, R, <span class="built_in">ls</span>(p), pl, mid, d);  <span class="comment">//递归左子树</span></span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid) <span class="built_in">updata</span>(L, R, <span class="built_in">rs</span>(p), mid+<span class="number">1</span>, pr, d);  <span class="comment">//递归右子树</span></span><br><span class="line">    <span class="built_in">push_up</span>(p);  <span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll L, ll R, ll p, ll pl, ll pr)</span>  <span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pl &gt;= L &amp;&amp; R &gt;= pr) <span class="keyword">return</span> tree[p]; <span class="comment">//完全覆盖(只可能恰好)，直接返回tree[p]，区间和</span></span><br><span class="line">    <span class="built_in">push_down</span>(p, pl, pr); <span class="comment">//不能覆盖，递归子树，先tag修改一下</span></span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    ll mid = (pl+pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) res += <span class="built_in">query</span>(L, R, <span class="built_in">ls</span>(p), pl, mid);  <span class="comment">//左子结点重叠（eg:[4,7],[5,8]</span></span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid) res += <span class="built_in">query</span>(L, R, <span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr);  <span class="comment">//递归右子树(eg:[7,9],[4,8])</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">built</span>(<span class="number">1</span>, <span class="number">1</span>, n);  <span class="comment">//建树</span></span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        ll q, L, R, d;</span><br><span class="line">        cin &gt;&gt; q;  <span class="comment">//选择操作</span></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; L &gt;&gt; R &gt;&gt; d;  <span class="comment">//区间修改</span></span><br><span class="line">            <span class="built_in">updata</span>(L, R, <span class="number">1</span>,<span class="number">1</span>, n, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; L &gt;&gt; R;  <span class="comment">//区间查询</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(L, R, <span class="number">1</span>, <span class="number">1</span>, n) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">* 基础操作<span class="number">1</span>：</span><br><span class="line">  * ①特殊的区间修改</span><br><span class="line">  * ②同时多种区间修改和区间查询</span><br><span class="line">  * ③线段树的二分操作</span><br><span class="line">  * ④离散化结果</span><br><span class="line">* 区间最值和区间历史最值</span><br><span class="line">  * <span class="number">1.</span>区间最值基本</span><br><span class="line">  * <span class="number">2.</span>区间历史最值</span><br><span class="line">* 区间合并</span><br><span class="line">  * 扫描线</span><br><span class="line">  * 矩形面积并</span><br><span class="line">  * 矩形周长并</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 二维线段树（树套树）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 可持久化线段树（主席树）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
</search>
