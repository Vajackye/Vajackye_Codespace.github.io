<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>myFirBlog</title>
    <url>/2024/03/18/myFirBlog/</url>
    <content><![CDATA[<h3 id="筛法的原理"><a href="#筛法的原理" class="headerlink" title="筛法的原理"></a>筛法的原理</h3><ul>
<li><p>质因数分解：任何大于 1 的正整数都能 唯一 的分解为有限个质数的乘积。根据这一定理任何一个合数都可以被分解成几个质数相乘的形式。</p>
<ul>
<li><p>可用于：求解约数个数，约数的和。因为某个正整数的约数也肯定等于质因数分解后的不同幂的乘积。</p>
</li>
<li><p>方法一(试除法，效率一般)：如360：360&#x2F;2 &#x3D; 180&#x2F;2 &#x3D; 90&#x2F;2 &#x3D; 45&#x2F;3 &#x3D; 15&#x2F;3 &#x3D; 5; 所以360的质因数乘积为2^3 * 3^2 * 5^1; 则其约数共有（3+1）（2+1）（1+1）&#x3D; 24个，即0-k次幂。</p>
<ul>
<li>试除法，可以把遍历范围改为<code>i &lt;= sqrt(n)</code>,因为有且最多有1个质因数大于合数的根号。证明：假设有俩质因数p1, p2大于sqrt(n),则 p1*p2 &gt; √n * √n &#x3D; n 。矛盾</li>
</ul>
</li>
<li><p>方法二：对于每个数，其约数总是成对出现的，比如 12 &#x3D; 3 * 4 &#x3D; 2 * 6….. 所以，我们只需要遍历到 (i &#x3D; 2; i * i &lt;&#x3D; n; i++)即可。唯一要注意的点就是，若 i * i &#x3D; n; 则只有一个约数，比如 25 &#x3D; 5^2</p>
</li>
<li><p><strong>题种三</strong>（欧拉筛求最小质因数+素数）：见代码：欧拉筛法部分，将vis改为记录素数即可，将vis的倍数被prime赋值（最小质因数）即可。</p>
</li>
<li><p>如本题：求一个正整数的约数的个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//法1：质因数分解</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  cin&gt;&gt;n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n % i == <span class="number">0</span>) <span class="comment">// 缩小n，加快速度，毕竟如 360 = 2^3 * 3^2 * 5^1, 当除了3次2，则剩下的数就缩小了。注：肯定都是质数，因为如4，已经被2除过了，所以%4 != 0, 即合数都不可能出现，已被拆分为质数了</span></span><br><span class="line">    &#123;</span><br><span class="line">      tmp++;</span><br><span class="line">      n /= i;<span class="comment">//缩小</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans *= (tmp + <span class="number">1</span>);<span class="comment">//+1是因为0次幂</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(n != <span class="number">1</span>)</span><br><span class="line">    ans *= (<span class="number">1</span>+<span class="number">1</span>); <span class="comment">//最后一个质数，比如上面的5，单独的</span></span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//法2：暴力求解 i*i &lt;= n</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  int main()</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    int n;</span></span><br><span class="line"><span class="comment">    int ans = 0;</span></span><br><span class="line"><span class="comment">    cin&gt;&gt;n;</span></span><br><span class="line"><span class="comment">    for(int i = 2; i*i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      if( n % i == 0)//找约数,加法，不存在合数被质数拆分</span></span><br><span class="line"><span class="comment">        ans += 2;</span></span><br><span class="line"><span class="comment">      if( i * i == n)</span></span><br><span class="line"><span class="comment">        ans--;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;ans;</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>题2：求约数之和; 原本的拆分质因数公式就是：y &#x3D; p1^k * p2^m * p3^n * ….</p>
</li>
<li><p>即约数之和可以写为：(p1^0 + p1^1 + … + p1^k) * (p2^0 + p2^1 +…..+ p2^m) <em>…..</em>(P.^0 + ……+ p.^y); <code>约数的每一个次幂都出现的乘积和</code></p>
<ul>
<li>进一步化简公式就是：等比数列求和: a1[p1^(k+1) - 1]&#x2F;(p1 - 1) * ….(p !&#x3D; 1; 其中的a1就是p1^0，首项，为1)</li>
<li>代码如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>( <span class="type">int</span>  i = <span class="number">2</span>; i*i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">       <span class="type">int</span> tmp = i;</span><br><span class="line">       <span class="keyword">while</span>( n % i == <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           tmp *= i;</span><br><span class="line">           n /= i;</span><br><span class="line">       &#125;</span><br><span class="line">       ans *= (tmp - <span class="number">1</span>) / (i - <span class="number">1</span>);<span class="comment">//a1=1</span></span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">if</span>(n != <span class="number">1</span>)</span><br><span class="line">       ans *= (n + <span class="number">1</span>); <span class="comment">// 因为（n^2 -1）/(n-1)</span></span><br><span class="line">   cout&lt;&lt;ans;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>题3：求模数：给定两个整数a, b; 问有多少个x，使得满足等式a mod x &#x3D; b,  如果存在无限个，输出”infinity”, 否则输出满足条件x的个数。</p>
</li>
<li><p>解析如下：</p>
<ul>
<li><p>如果a&#x3D;&#x3D;b , 只要mod的x大于a或b，肯定有无数个，比如 3 mod 4&#x2F;5&#x2F;6&#x2F;7…. &#x3D; 3</p>
</li>
<li><p>如果a&lt;b, 则不存在mod x使得 等于b 为0</p>
</li>
<li><p>如果a&gt;b, 则求(a - b) mod x &#x3D;&#x3D; 0 , 那么只要对(a - b)取约数，只要找到 i &lt; b, 则+1，其中i从1开始。约数成对出现，要保证其另一个约数也大于b，则再++（并且该约数不能 (a - b) &#x2F; i &#x3D; i）</p>
</li>
<li><p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">if</span>(a == b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;infinity&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( a &lt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a -= b;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= a; i++) <span class="comment">//从一开始，不是完全素数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; b) ans++;</span><br><span class="line">            <span class="keyword">if</span>(a / i &gt; b &amp;&amp; a / i != i) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>题四:数树：在第一象限的坐标系中，若某点与（0，0）连线成的树没有被其他树覆盖，就称该树是可见的。比如：（5，3）可见，（4，2）不可见，因为被（2，1）覆盖。请计算n*n范围内可见树</p>
<ul>
<li><p>题解：n&#x3D;(0,2000),c&#x3D;(0,10)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//即a mod b == 1 ; b mod a == 1; 即最大公约数为1即可见。否则有约数都会被约数更小覆盖。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y == <span class="number">0</span> ? x : <span class="built_in">gcd</span>(y, x%y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cin&gt;&gt;c;<span class="comment">//测试数据组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">gcd</span>(k, j) == <span class="number">1</span>)</span><br><span class="line">                    ans++; </span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans+<span class="number">2</span>&lt;&lt;endl;<span class="comment">//不要忘了坐标轴的两条树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>哥德巴赫猜想：任何一个偶数可以拆成两个质数之和。（奇数可以拆成质数和偶数之和，偶数如果为2则也为奇数，如果&gt;2,则也可以拆成两个质数）</p>
<ul>
<li><p>相关题目：交税，税收是n收入的最大因子（不包含本身n的因子），为了减少税钱，把n拆成多份，使得交的钱最少</p>
</li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prime</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i*i &lt;= num; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (num %i== <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">prime</span>(n))   cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (n %<span class="number">2</span>==<span class="number">0</span>)  cout &lt;&lt; <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">prime</span>(n - <span class="number">2</span>))  cout &lt;&lt; <span class="number">2</span>;<span class="comment">//n-2如果等于质数，则为质数+2（质数），则只要交最大因子，各为1，共2，如果不是，则下面的输出，大于2的偶数拆成2个质数。</span></span><br><span class="line">   <span class="keyword">else</span>   cout &lt;&lt; <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>素数筛法</p>
<ul>
<li><p>埃氏筛法（O(nloglogn)</p>
<ul>
<li><p>对初始的队列{1，2，3,….,n},进行以下操作:</p>
<ul>
<li>输出最小素数2，然后筛掉2的倍数</li>
<li>输出最小素数3，然后筛掉3的倍数</li>
<li>输出最小素数5，然后筛掉5的倍数</li>
<li>……..</li>
</ul>
</li>
<li><p>一直重复以上步骤，直到队列为空。</p>
</li>
<li><p>下面给出代码：visit[i]用于记录数i的状态，visit[i] &#x3D; true表示被筛掉了,不是素数。prime[]存放素数，如prime[0]是第一个素数2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>; <span class="comment">//定义空间，可根据题目改动</span></span><br><span class="line"><span class="type">int</span> prime[N + <span class="number">1</span>]; <span class="comment">//存储素数，记录visit[i] = false的项</span></span><br><span class="line"><span class="type">bool</span> visit[N + <span class="number">1</span>]; <span class="comment">// true表示被筛掉</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">E_sieve</span><span class="params">(<span class="type">int</span> n)</span>  <span class="comment">//埃式筛法，算2-n之间的素数</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="type">int</span>  k = <span class="number">0</span>; <span class="comment">//统计素数个数</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) visit[i] = <span class="literal">false</span>; <span class="comment">// 初始化</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;=n; i++) <span class="comment">//从第一个素数2开始 （1）优化</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[i])</span><br><span class="line">        &#123;</span><br><span class="line">           prime[k++] = i; <span class="comment">//i是素数，存储到prime中</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span> * i; j &lt;= n; j += i)  <span class="comment">//i的倍数，都不是素数，筛掉。（2）优化</span></span><br><span class="line">                visit[j] = <span class="literal">true</span>;  <span class="comment">//标记为非素数</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> k;  <span class="comment">//返回素数的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>可优化（1），（2）；（1）处，做筛出的数字2，3，5，…，√n（根号n）就可以了。因为非素数k一定可以被一个小于或等于√n的素数整除，被筛出。</p>
</li>
<li><p>（2）处，j &#x3D; 2 * i，可改为j &#x3D; i * i，因为如i &#x3D; 5，则2 * 5，3 * 5，4 * 5，已经筛出过了</p>
</li>
<li><p>优化后算法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">E_sieve</span><span class="params">(<span class="type">int</span> n)</span>  <span class="comment">//埃式筛法，算2-n之间的素数</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     <span class="type">int</span>  k = <span class="number">0</span>; <span class="comment">//统计素数个数</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) visit[i] = <span class="literal">false</span>; <span class="comment">// 初始化</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++) <span class="comment">//优化为sqrt</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[i])</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j = i * i; j &lt;= n; j += i)  <span class="comment">//i的倍数，都不是素数，筛掉，优化为i*i</span></span><br><span class="line">                visit[j] = <span class="literal">true</span>;  <span class="comment">//标记为非素数</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!visit[i]) prime[k++] = i;<span class="comment">//存储素数</span></span><br><span class="line">     <span class="keyword">return</span> k;  <span class="comment">//返回素数的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>欧拉筛法（O(n)，是线性筛。更优于埃式筛法）</p>
<ul>
<li><p>原理：每一个合数肯定有一个最小质因数；让每个合数只被它的最小质因数筛选一次，以达到不重复筛的目的。</p>
</li>
<li><p>具体操作：（1）逐一检查2-n之间的所有数，第一个检查的是2，是第一个素数；（2）当检查到第i个数时，利用已经求得的素数去筛掉对应的合数x，而且是用x的最小质因数去筛。</p>
</li>
<li><p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> prime[N]; <span class="comment">//保存素数，节约空间的话可缩小大小</span></span><br><span class="line"><span class="type">bool</span> vis[N]; <span class="comment">//记录是否被筛</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_sieve</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">//欧拉筛，返回素数的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 记录素数个数</span></span><br><span class="line">   <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)); <span class="comment">// 初始化</span></span><br><span class="line">   <span class="built_in">memset</span>(prime,<span class="number">0</span>,<span class="built_in">sizeof</span>(prime)); <span class="comment">// 初始化</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="comment">// 检查每个数，删除其中的合数</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[i]) prime[cnt++] = i; <span class="comment">// 如果没有筛过，是素数，记录；第一个素数为2</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)  <span class="comment">//用已经得到的素数去筛出后面的数</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span>(i * prime[j] &gt; n) <span class="keyword">break</span>; <span class="comment">//只筛选小于或等于n的数字</span></span><br><span class="line">         vis[i * prime[j]] = <span class="number">1</span>; <span class="comment">//关键1：用x的最小质因数筛去x</span></span><br><span class="line">         <span class="keyword">if</span>(i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//关键2：如果不是这个数的最小质因数，则结束。</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>模板题：求出[1,n]之间的质数率（质数占比）</p>
</li>
<li><p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span>;</span><br><span class="line"><span class="type">int</span> prime[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">euler_sieve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//记录素数个数</span></span><br><span class="line">    <span class="comment">//memset(prime, 0, sizeof(prime));</span></span><br><span class="line">    <span class="comment">//memset(vis, 0, sizeof(vis));</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime[cnt++] = i;<span class="comment">//记录素数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)<span class="comment">//用前面的素数筛掉后面的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i * prime[j] &gt; n) <span class="keyword">break</span>; <span class="comment">//排除掉大于n的数字</span></span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>; <span class="comment">//最小质因数筛掉合数</span></span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//避免重复筛，提前退出，比如12，又被2筛，被3筛</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//欧拉筛</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n); </span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    count = <span class="built_in">euler_sieve</span>(n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, (<span class="type">double</span>)count / n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="筛法的思想与应用"><a href="#筛法的思想与应用" class="headerlink" title="筛法的思想与应用"></a>筛法的思想与应用</h4><ul>
<li><p>给你t个数字，如果这个数X是喜欢数，则输出下一个喜欢数；如果这个数X不是喜欢数，输出-1。（0默认不是喜欢数）</p>
<ul>
<li><p>条件1：7的倍数都不是喜欢数（包含7）</p>
</li>
<li><p>条件2：数字中任一位含有7的倍数都不是喜欢数（包含该数）</p>
</li>
<li><p>数据范围：1&lt;&#x3D; t &lt;&#x3D; 2e5; 0 &lt;&#x3D; X &lt;&#x3D; 1e7;</p>
</li>
<li><p>例解c++：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>;</span><br><span class="line"><span class="type">int</span> like[N];</span><br><span class="line"><span class="type">bool</span>  vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( number &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(number % <span class="number">10</span> == <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        number /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>; <span class="comment">// 索引，返回数字查找下一个喜欢数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">// 已经遍历了最小倍数，防止出错</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i)) <span class="comment">// 检索所有</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= N; j += i)</span><br><span class="line">                vis[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            like[cnt++] = i;</span><br><span class="line">            cnt = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>); cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">my_sieve</span>();</span><br><span class="line">    <span class="type">int</span> t, num;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        <span class="keyword">if</span>(vis[num] || num == <span class="number">0</span>) cout&lt;&lt; <span class="number">-1</span> &lt;&lt;endl; <span class="comment">// 卡常0</span></span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;like[num]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>基础算法</title>
    <url>/2024/03/19/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h3><ul>
<li><p>快排板子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x = q[(l + r) &gt;&gt; <span class="number">1</span>]; <span class="comment">//x = q[l], x=q[r];但是x=q[l + r &gt;&gt; 1]效率最高</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//若i: i-1,i ,对应x = (l+r+1)&gt;&gt;1 或 r，保证上取整，否则死循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>归并板子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>二分板子</p>
<ul>
<li><p>整数二分</p>
<ul>
<li><p>左边界</p>
</li>
<li><p>右边界</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;<span class="comment">//一般为:a[mid]&lt;=x, mid已左下取整，所以不用mid-1，向下取整则r往左取边界（包含if(a[mid]==x)这一答案了</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="comment">//一般为:a[mid]&gt;=x, mid已右上（mid有+1）取整，所以不用mid+1，向上取整则l往往取边界（包含if(a[mid]==x)这一答案了</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可用于求区间范围等，第一种是默认l(除左）,第二种是默认r（除右）</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>实数二分（float二分）</p>
<ul>
<li><p>while至少比要求有效位数多两个精度（进位精度）</p>
</li>
<li><p>或for循环100次（精度基本绝对够了$2^{-100}$）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>; <span class="comment">//不可以&gt;&gt;1.0，因为移位针对整数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//针对某些例题，如开根，可能有数字在-1~1之间，这样如果，l=0,r=n的话，可能存在l和r的区间本来就不包含正确答案，不妨按照题目n范围，设置l和r，多迭代几次，这样，能确保所有答案都在里面。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>高精度板子</p>
<ul>
<li><p>倒序相加，倒序输出。(string a, b)</p>
</li>
<li><p>高精度加法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用vector方便，不用统计size</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i++) <span class="comment">//满足一个继续。下面的if判断是否加超过size的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">    	<span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">    	c.<span class="built_in">push_back</span>(t%<span class="number">10</span>); <span class="comment">//除掉进位</span></span><br><span class="line">    	t /= <span class="number">10</span>; <span class="comment">//进位</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(t) c.<span class="built_in">push_back</span>(<span class="number">1</span>); <span class="comment">//若t仍有进位（最高位）</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//string a, b; cin&gt;&gt;a&gt;&gt;b; //a=&#x27;12345&#x27; for(int i = a.size()-1; i&gt;=0; i--) A.push_back(a[i]-&#x27;0&#x27;); //相对偏移且倒序，确保低位相加</span></span><br><span class="line"><span class="comment">//for(int i = c.size()-1; i&gt;=0; i++) cout&lt;&lt;c[i];//倒序输出 </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>高精度减法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//减法需要判断正负</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>(); <span class="comment">//A&gt;B:true,else false</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(A[i]!=B[i]) <span class="keyword">return</span> A[i]&gt;B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//全相等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, vector&lt;<span class="type">int</span>&gt; B)</span><span class="comment">//在main处理了A大于B，也可以在这里处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t; <span class="comment">//先剪掉借位</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        c.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>);<span class="comment">//保证了t&gt;0,仍为t，t&lt;0,为补码</span></span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;<span class="comment">//有借位，为1，不是-1.t为借位标记。</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;<span class="comment">//无</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; c.<span class="built_in">back</span>() == <span class="number">0</span>) c.<span class="built_in">pop_back</span>(); <span class="comment">//去掉前导0</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A, B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = b.<span class="built_in">size</span>()<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) B.<span class="built_in">push_back</span>(b[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A, B))</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">auto</span> c = <span class="built_in">Sub</span>(A, B); </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = c.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            cout&lt;&lt;c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> c = <span class="built_in">Sub</span>(B, A);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = c.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            cout&lt;&lt;c[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高精度乘低精度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(A[i]+t)%10为本位, /10为进位</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	vector&lt;<span class="type">int</span>&gt; c;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">		t =  t + A[i] * b; <span class="comment">//加t，进位。</span></span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>; <span class="comment">//进位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) c.<span class="built_in">push_back</span>(t);<span class="comment">//最高位进位</span></span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>高精度除低精度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A/b, r为余数，c为商</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span> &gt; c;</span><br><span class="line">    r = <span class="number">0</span>;<span class="comment">//余数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];<span class="comment">//no ：r&lt;&lt;1,此为2进制</span></span><br><span class="line">        c.<span class="built_in">push_back</span>(r/b); <span class="comment">//商数位，从高到低</span></span><br><span class="line">        r %= b;<span class="comment">//余数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());<span class="comment">//用于删除前导零，要反转：pop.back()</span></span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; c.<span class="built_in">back</span>()==<span class="number">0</span>) c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>前缀和</p>
<ul>
<li><p>一维</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], s[N]; <span class="comment">//a为元素，s为前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preSum</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> <span class="comment">//a也是从[1]开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间求和：[r, l] : sum = s[r] - s[l-1]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>二维</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N][N], s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preSum</span><span class="params">(<span class="type">int</span> **a, <span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>] + a[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间求和[(x1,y1),(x2,y2)]：sum = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1];</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>差分</p>
<ul>
<li><p>一维</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造b为a的差分，则a为b的前缀和</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间每个数+c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//差分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">insert</span>(i, i, a[i]); <span class="comment">//先初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] += b[i<span class="number">-1</span>]; <span class="comment">//求前缀和。</span></span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= n; i++) cout&lt;&lt;b[i];</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>二维</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//差分区间改变+c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>] -= c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//差分</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        <span class="built_in">insert</span>(i, j, i, j, a[i][j]);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">insert</span>(x1, y1, x2, y2, c); <span class="comment">//区间+c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//求前缀和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;=m; j++)</span><br><span class="line">        b[i][j] += b[i<span class="number">-1</span>][j] + b[i][j<span class="number">-1</span>] - b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        cout&lt;&lt;b[i][j];<span class="comment">//输出。</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>位运算</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//题种1：求第k位为0/1：</span></span><br><span class="line">n &gt;&gt;= k <span class="comment">//(n为10进制的2表示，左移k位)</span></span><br><span class="line">cout&lt;&lt;n&amp;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//题种2：求1的个数（每次返回最后一个1的大小，原数减去其，继续操作，直到为0）</span></span><br><span class="line"><span class="comment">//lowbit取补码操作，常用于树状数组，在c++中，-x用补码表示，即-x = ~x+1</span></span><br><span class="line"><span class="comment">//返回n的最后一位1：</span></span><br><span class="line"><span class="built_in">lowbit</span>(n) = n &amp; -n;<span class="comment">//-n为补码</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>双指针</p>
</li>
<li><p>用不习惯。。。</p>
<ul>
<li><pre><code class="c++">//j为slow指针，i为fast指针
for(int i = 0, j = 0; i &lt; n; i++)
&#123;
    while(j &lt; i &amp;&amp; check(i,j)) j++; 
    //问题逻辑
&#125;

//我的逻辑：一般先将题目排序（若可），再指针迭代（同上，类似）。

//一般具有某种单调关系。
//常见问题分类：
//(1) 对于一个序列，用两个指针维护一段区间
//(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="operator"></span></span><br><span class="line"><span class="operator">  </span></span><br><span class="line"><span class="operator"></span></span><br><span class="line"><span class="operator">* </span>离散化<span class="operator"></span></span><br><span class="line"><span class="operator"></span></span><br><span class="line"><span class="operator">  * </span>即将大数映射到小index上（即使得离散化数据连续存储）（保序离散化：小更小，大更大。即映射下标）</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  <span class="comment">//数组a中可能有重复元素，需要去重：vector排序去重</span></span><br><span class="line">  <span class="comment">//如何迅速算出a[i]离散化后对应的index：二分</span></span><br><span class="line">  </span><br><span class="line">  vector&lt;<span class="built_in">int</span>&gt; alls; <span class="comment">//存储所有离散化的值</span></span><br><span class="line">  sort(alls.<span class="keyword">begin</span><span class="literal">()</span>,alls.<span class="keyword">end</span><span class="literal">()</span>);</span><br><span class="line">  alls.erase(unique(alls.<span class="keyword">begin</span><span class="literal">()</span>, alls.<span class="keyword">end</span><span class="literal">()</span>),alls.<span class="keyword">end</span><span class="literal">()</span>);<span class="comment">//去掉重复元素</span></span><br><span class="line">  <span class="comment">//unique返回将重复元素移到最后的第一个重复元素的下标，从此开始到终止，全部删除。</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//二分求出x对应离散化值</span></span><br><span class="line">  <span class="built_in">int</span> find(<span class="built_in">int</span> x) <span class="comment">//找到第一个&gt;=x的位置</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">int</span> l = <span class="number">0</span>, r = alls.size<span class="literal">()</span>-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="built_in">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">if</span>(allss[mid] &gt;= x) r = mid;</span><br><span class="line">          <span class="keyword">else</span> l = mid<span class="operator"> + </span><span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      return r+<span class="number">1</span>; <span class="comment">//+1表示从下标1开始映射，不加1表示从0开始映射。在a[]数组找相对位置，返回给数组b</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>区间合并</p>
<ul>
<li><code>pair</code>排序优先左端点排序，再右端点排序</li>
<li>先将所有区间的端点按左端点排序（右端点也可以，处理稍微不同）</li>
<li>贪心算法，主要是3种情况，A与B线段有交集，A与B线段重合（设B小于A），A与B线段无交集</li>
<li>其中第一种和第二种可以合并为一种：更新尾边界为<code>max</code>A与B尾部。第二种则更新边界。</li>
<li>开局可设左右端点为正负无穷</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有存在交集的区间和并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector&lt;PII&gt; res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>()); <span class="comment">//默认按pair第一个first排序。</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>; <span class="comment">//开始设边界无穷小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg: segs)</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first) <span class="comment">//第一个右边界小于第二个左边界，则无交集,情况3</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">puh_back</span>(&#123;st, ed&#125;); <span class="comment">//!=-2e9确保开始的输入正确。</span></span><br><span class="line">            st = seg.first;</span><br><span class="line">            ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);<span class="comment">//第1，2种情况，更新尾边界</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(st!=<span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);<span class="comment">//确保不是输入为空（最边界），将最后一组区间放入。</span></span><br><span class="line">    </span><br><span class="line">    segs = res; <span class="comment">//放回。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
</search>
